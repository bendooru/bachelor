\documentclass[
  paper=a4,
  titlepage,
  bibliography=totoc,
  pagesize=pdftex
]{scrartcl}
% TMP
\overfullrule=1mm
% TMP
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[autostyle=true]{csquotes}
\usepackage{enumitem}
\usepackage{mathtools,amsfonts,amssymb,amsthm,mathrsfs}
\usepackage{lmodern}
\usepackage{dsfont}

\usepackage[svgnames]{xcolor}
\usepackage{listings}
\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  moredelim=[s][\bfseries\color{Maroon}]{<}{\ },
  moredelim=[s][\bfseries\color{Maroon}]{</}{>},
  moredelim=[l][\bfseries\color{Maroon}]{/>},
  moredelim=[l][\bfseries\color{Maroon}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{DarkOliveGreen},
  stringstyle=\color{blue},
  identifierstyle=\color{red},
  showstringspaces=false
}

\usepackage[noend]{algpseudocode}
\algrenewcommand\algorithmicrequire{\textbf{Input:}}
\algrenewcommand\algorithmicensure{\textbf{Output:}}

\usepackage[
  activate={true,nocompatibility},
  kerning=true,
  spacing=true
]{microtype}
\microtypecontext{spacing=nonfrench}

\usepackage{subcaption}

\usepackage{pgf,tikz}
\usetikzlibrary{calc,shapes,automata,petri}
\tikzset{%
  transition/.style={rectangle,minimum size=6mm,draw},
  place/.style={circle,minimum size=6mm,draw},
  database/.style={% props to Christian
    minimum width=2cm,minimum height=1cm,cylinder,
    shape border rotate=90,aspect=0.2,draw
  }
}
% FIXME REMOVE LATER
\usepackage[textsize=footnotesize]{todonotes}
% FIXME END

\usepackage[pdftex,hidelinks]{hyperref}

\usepackage[
  backend=biber,
  style=alphabetic,
  maxnames=10,
  maxalphanames=5,
  isbn=false
]{biblatex}
\addbibresource{bachelor.bib}

% serif > sans-serif
\setkomafont{sectioning}{\rmfamily\bfseries\boldmath}
\setkomafont{descriptionlabel}{\rmfamily\bfseries\boldmath}
% prefix all numbers with section
\numberwithin{figure}{section}
\numberwithin{equation}{section}
\numberwithin{table}{section}

% set default numbered list style to (i), (ii), ...
\setlist[enumerate,1]{label=(\roman*)}
\setlist[itemize,2]{label=$\circ$}

% use mathds instead of mathbb
\newcommand*\setZ{\mathds{Z}}
\newcommand*\setR{\mathds{R}}
\newcommand*\setC{\mathds{C}}
\newcommand*\setQ{\mathds{Q}}
\newcommand*\setN{\mathds{N}}
\newcommand*\setK{\mathds{K}}
\newcommand*\setA{\mathds{A}}
\newcommand*\setP{\mathds{P}}
\newcommand*\setT{\mathds{T}}
\newcommand*\ii{\mathrm{i}}

\newcommand{\Cpp}{C\nolinebreak\texttt{++}}

\widowpenalty9999

% number a single equation in unnumbered environment
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand*\dotcup{\mathbin{\dot{\cup}}}

% shorthands
\newcommand*\vectRR[2]{\begin{pmatrix} #1 \\ #2 \end{pmatrix}}
\newcommand*\ideal[1]{\left\langle #1 \right\rangle}
\newcommand*\puiseux[2]{#1\{\!\{#2\}\!\}}
\newcommand*\CCt{\puiseux{\setC}{t}}

\let\vec\mathbf
\let\idealof\trianglelefteq

% operators
\DeclareMathOperator{\Mat}{Mat}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Trop}{Trop}
\DeclareMathOperator{\trop}{trop}
\DeclareMathOperator{\initial}{in}
\DeclareMathOperator{\face}{face}
\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\GR}{GR}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\Lin}{Lin}
\DeclareMathOperator{\codim}{codim}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\Grass}{Grass}

% use same counters for all environments
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{example}[definition]{Example}
\newtheorem{remark}[definition]{Remark}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{algo}[definition]{Algorithm}
\newtheorem{corollary}[definition]{Corollary}

% adjust numbering
\numberwithin{definition}{section}

% not properly hyphenated in English
\hyphenation{Kai-sers-lau-tern}
\hyphenation{Tech-ni-sche}

\subject{Bachelor's Thesis}
\title{Massively Parallel Computation of Tropical Varieties}
\author{Dominik Bendle\\{\small Matrikelnr.: 392713}}
% hacky
\publishers{%
  \begin{tabular}{ll}
    First examiner:  & Dr.~Janko Böhm \\
    Second examiner: & Prof.~Dr.~Andreas Gathmann \\
                     & \\
    Supervisors:     & Dr.~Janko Böhm \\
                     & Dr.~Mirko Rahn
  \end{tabular}\\[3em]
  Fachbereich Mathematik\\
  Arbeitsgruppe Algebra, Geometrie und Computeralgebra\\[1em]
  \includegraphics[scale=1.5]{fig/TUKL.eps}\\[1em]
  {\small
    in cooperation with\\
    Fraunhofer-Institut für Techno- und Wirtschaftsmathematik
  }
}

\date{Kaiserslautern, \today}

\begin{document}
\numberwithin{lstlisting}{section}

\pagestyle{empty}
\maketitle

% make sure toc starts on page 3
\clearpage\null\clearpage
\pagestyle{plain}
\tableofcontents
\newpage
\listoffigures
\listoftables
\lstlistoflistings
\newpage

\pagestyle{headings}
\addtokomafont{section}{\clearpage}

\section{Introduction}

Tropical geometry is a relatively new field in mathematics that studies algebraic
varieties in a combinatorial fashion, reducing algebraic problems to polyhedral ones in
the process. In particular, the \emph{tropical varieties} arising in this field are
sometimes referred to as the \enquote{combinatorial shadow} of their algebraic
counterpart. The general idea is to pass from classical arithmetic to \emph{tropical
arithmetic}, where one replaces addition and multiplication with taking minima and
classical addition, respectively. This turns the graphs of polynomial functions into
piecewise linear objects and the tropical varieties are the \emph{corner loci} of these
objects. An important application of tropical geometry includes intersection theory which
deals with intersections between subvarieties of an algebraic variety and is for example
used to count numbers of solutions to geometric questions \cite{mikhEnum}: Many theorems
have counterparts in tropical geometry or even carry over entirely. As usual,
mathematicians are interested in studying concrete examples of tropical varieties -- for
instance to gain a general intuition behind the combinatorial structures or to find
counterexamples

While this process of \emph{tropicalization} yields objects that are far easier to
describe and compute than their algebraic counterparts, it is not hard to construct
examples that cannot be computed in reasonable time frames using purely sequential legacy
algorithms that are in use now, mainly Gfan \cite{gfan} and the \textsc{Singular} library
\texttt{tropical.lib} \cite{tropLib}. There are mainly two ways of tackling this issue:
Firstly, one could attempt to devise new theories and algorithms to reduce the
computational requirements behind the problems. This, however, will eventually suffer from
the limits of our legacy applications as well. Secondly and more importantly, we may
identify and modify the parts of existing methods which are suitable for parallelization
to utilize the capabilities of modern computers to the fullest. In particular, the aim is
to exploit parallel structures of the mathematical problems in order to use these
resources with maximum efficiency.

To this end, one usually considers two kinds of parallelization. On \emph{shared memory
systems} a single process uses multiple threads while processing shared data, allowing for
fine-grained parallelism. In this, they are limited by the number of processors that are
able to access shared memory and only work in a local sense. On \emph{distributed} and
\emph{multi-process systems} data is processed by different processes which do not share
memory but instead communicate by message passing or a joint virtual memory layer. This
only provides coarse-grained parallelism, but can in theory scale to arbitrarily large
computing configurations.

Our contribution in this thesis is a combination of both of these approaches: We apply the
latter kind of paralellization method mentioned above to existing methods to compute
tropical varieties. Methods of computing tropical varieties have been studied by Tristram
Bogart, Anders Jensen, David Speyer, Benrd Sturmfels and Rekha Thomas \cite{compTropVar}
and further improved by Yue Ren and Tommy Hofmann \cite{tropPointsLinks}. These methods
constitute the \enquote{lower} level of the final parallel algorithm and are implemented
in the computer algebra system \textsc{Singular} \cite{Singular} which is being developed
at the University of Kaiserslautern. In particular, tropical computations are carried out
by methods of the library \texttt{tropicalNewton.lib} \cite{tropNewtLib} which relies on
Gfan \cite{gfan} for polyhedral computations via the interface library \texttt{gfan.lib}
\cite{gfanLib}. Instances of \textsc{Singular} processes are then managed by the workflow
management system GPI-Space \cite{gpispace} at the \enquote{upper} level, that is, the
coordination layer. GPI-Space is developed by the High Performance Computations (HPC)
department at Fraunhofer Institute for Industrial Mathematics (ITWM).

Our parallelization solution is based on work by Christian Reinbold who used GPI-Space to
implement a parallel algorithm to compute GIT-fans \cite{reinboldGitFan}, using algorithms
by Janko Böhm, Simon Keicher and Yue Ren \cite{compGitFan}. This, in turn, relies on
foundational work done by Lukas Ristau in creating interface code to use \textsc{Singular}
in conjunction with GPI-Space. As tropical varieties admit the structure of a polyhedral
fan as well, we were able to successfully modify Christian Reinbold's implementation to
handle computation of tropical varieties instead. The development was coordinated in
cooperation with the HPC department of Fraunhofer ITWM, in particular with the support of
Dr.~Mirko Rahn and Christian Reinbold. Additionally, as a side effect we accelerated the
development of \texttt{puiseux.lib} \cite{puiseuxLib}, which is used to compute Puiseux
expansions of zero-dimensional ideals as. This is required by the methods in
\cite{tropPointsLinks} as a special case. Moreover, during our work with \textsc{Singular}
we were able to identify various bugs, for example memory leaks.

Using our parallel algorithm we were able to compute the tropical Grassmannian $\mathcal
G_{3,8}$ modulo symmetry in its entirety, which has not been possible with legacy methods
until now. Using this as a benchmark, we also found that our algorithm scales favorably
for large numbers of processor cores. In fact, our algorithm scales well to as many as 56
compute nodes, which corresponds to 896 processor cores, reducing the running time to
20\,minutes.

The thesis is structures as follows: In Section~\ref{sec:theory} we will describe the
general setting in which we want to compute tropical varieties. For this purpose, we
introduce various notions concerning fields with valuation and convex geometry. We then
define tropical varieties and study their properties as polyhedral convexes. Finally, we
illustrate how to compute tropical varieties using methods from \cite{compTropVar} and
describe improvements using new techniques from \cite{tropPointsLinks}. In the third
section we give an account on GPI-Space and the concept of Petri nets, which is used in
GPI-Space to formulate parallelizable workflows. Subsequently we translate our traversal
algorithm into such a Petri net. In the fourth section we consider the tropical
Grassmannians, an important class of tropical varieties, and give timings for parallel
computations of $\mathcal G_{3,7}$ and $\mathcal G_{3,8}$.

\subsubsection*{Acknowledgements}
Firstly I thank Dr.~Janko Böhm for suggesting this topic to me, giving me
the chance to work at Fraunhofer ITWM and guiding me in understanding tropical varieties
and their computation. In this vein, I thank Dr.~Yue Ren and Dr.~Tommy Hofmann for their
support in understanding and adapting their \textsc{Singular} implementation. Special
thanks goes to Santiago Laplagne, who, during his stay in Kaiserslautern, tirelessly
implemented and improved a \textsc{Singular} library for computations with general Puiseux
series expansions. Similarly, I thank Dr.~Hans Schönemann who quickly provided
fixes to some annoying bugs we found in \text{Singular}.

I thank my friend Kasimir for helping proofread this thesis and providing his
linguistic assistance while having to deal with this \enquote{mathematical nonsense}.

In addition, I thank Dr.~Mirko Rahn from the High Performance Computing (HPC) department
at Fraunhofer ITWM for his guidance and help during my work there. I further thank
Christian Reinbold for his helpful introduction to his project and providing a working
code base. My final thanks go to the HPC department and Fraunhofer ITWM in general for
providing access to their massive computation infrastructure, without which this thesis
would not have been possible.

\section{Computing Tropical Varieties}
\label{sec:theory}

Tropical geometry is a relatively new field in mathematics that arises from numerous
contexts and connects various branches of mathematics in exciting and novel ways. We shall
provide a basic introduction to this topic while focusing on the computational aspects,
which will lead to the main interest of this thesis -- the recently developed techniques
using Newton polygons and valuations.

Over the course of this section we need some basic definitions from algebraic geometry: We
fix a field $K$ which is usually assumed to be algebraically closed: The \emph{affine
space} over $K$ of dimension $n$ is
\[
  \setA_K^n = \setA^n = \left\{ (a_1,\dots,a_n) : a_i \in K\right\} = K^n
\]
and the \emph{projective space} over $K$ of dimension $n$ is $\setP^n_K = \setP^n =
(K^{n+1}\setminus\{0\})/\sim$ with equivalence relation $v \sim \lambda v$ for all $v \in
K^n\setminus \{0\}$ and $\lambda \in K^*$. Elements $a \in \setP^n$ are usually written as
homogeneous coordinates $(a_1:\cdots:a_n)$ for a representative $(a_0, \dots, a_n)$. An
\emph{affine variety} is the common zero locus of all the polynomials of a polynomial
ideal $I \idealof K[x_1, \dots, x_n]$, that means sets of the form
\[
  X = V(I) = \{ a \in \setA^n : f(a) = 0 \text{ for all $f\in I$} \} \subseteq \setA^n.
\]
In the special case of a homogeneous ideal $I \idealof K[x_0,\dots,x_n]$, which means $I$
is generated by homogeneous polynomials -- we may define \emph{projective varieties}
\[
  X = V(I) = \left\{ (a_0:\cdots:a_n) \in \setP^n : f(a_0, \dots, a_n) = 0
    \text{ for all $f \in I$}
  \right\} \subseteq \setP^n.
\]
The homogeneity assumption is necessary since otherwise $f(a)$ being zero is not
independent of the representative $(a_0,\dots,a_n)$ of $(a_0:\cdots:a_n)\in \setP^n$.

\subsection{Basic Tropical Geometry}
\label{sec:tropIntro}

The standard approach to tropical geometry is to consider the semiring $(\setR \cup
\{\infty\}, \min, +)$ with the classical addition replaced with taking the minimum and
classical multiplication replaced with addition. An in-depth introduction to tropical
geometry and tropical varieties is given by \cite{sturmMacTrop}, similar notions focused
on computation can be found in \cite{compTropVar}.

We denote by $\oplus$ and $\odot$ the \enquote{addition} and \enquote{multiplication}
defined above, so -- just to reiterate -- we have that
\[
  x \oplus y = \min(x,y)
  \qquad \text{and} \qquad
  x \odot y = x+y
\]
for elements $x,y\in \setR\cup\{\infty\}$, for example $4\oplus9 = 4$ and $4\odot9 = 13$.
It is easy to verify that the usual arithmetic laws are still valid: $\oplus$ and $\odot$
are commutative and satisfy distributivity. Furthermore, there is a unique neutral
element for both operations: For all $x\in \setR\cup \{\infty\}$ it is true that
\[
  x \oplus \infty = x
  \qquad \text{and} \qquad
  x \odot 0 = x.
\]
As in proper rings, the neutral element of $\oplus$ has the annihilating property with
respect to $\odot$, i.e.\ $x\odot \infty = \infty$. An important property of this set is
that, while elements in $\setR$ admit a multiplicative $\odot$-inverse (the traditional
additive inverse), there is in general no additive $\oplus$-inverse. For example, the
equation $4\oplus x = 5$ clearly has no solution. In this setting, all ring axioms except
the existence of an additive inverse are satisfied: Sets like this are called
\emph{semirings}, hence we call $(\setR\cup \{\infty\}, \oplus, \odot)$ the \emph{tropical
semiring} which is sometimes also referred to a as the \emph{min-plus algebra}. By
replacing taking minima with maxima, we obtain the isomorphic max-plus algebra which, is
also used as the underlying structure in tropical geometry by some authors. These special
operations of addition and multiplication naturally lead to the notion of polynomials over
the tropical semiring.

\begin{definition}[Tropical Polynomials]
  \label{def:tropPoly}
  Let $x_1, \dots, x_k$ be variables with values in $\setR\cup\{\infty\}$, then due to
  commutativity we can write arbitrary products of variables as
  \[
    x_{i_1} \odot x_{i_2} \odot \cdots \odot x_{i_m}
    = x_1^{\alpha_1} \cdots x_k^{\alpha_k}
  \]
  for suitable $\alpha_1, \dots, \alpha_k \in \setN$. We call this a \emph{tropical
  monomial}. Translating back into the traditional operations shows that the tropical
  monomials
  \[
    x_1^{\alpha_1} \cdots x_k^{\alpha_k} =
    \underbrace{x_1\odot\cdots\odot x_1}_{\alpha_1 \text{ times}}
    \odot\cdots\odot
    \underbrace{x_k\odot\cdots\odot x_k}_{\alpha_k \text{ times}}
    = \alpha_1x_1 + \cdots + \alpha_kx_k
  \]
  are just linear polynomials with integer coefficients. A \emph{tropical polynomial} is
  then defined as a finite $\setR$-linear combination of tropical monomials with respect
  to tropical arithmetic:
  \[
    p = a_1 \odot x_1^{\alpha_{1,1}}\cdots x_k^{\alpha_{1,k}} \oplus \cdots \oplus
    a_m \odot x_1^{\alpha_{m,1}}\cdots x_k^{\alpha_{m,k}}
  \]
  with exponents $\alpha_{i,j} \in \setN$, $1\leq i \leq m, 1\leq j \leq k$ and real
  coefficients $a_i \in \setR$. Note that if $a_i = 0$ for some $i$ we have that $a_i\odot
  x_1^{\alpha_{i,1}}\cdots x_k^{\alpha_{i,k}} = x_1^{\alpha_{i,1}}\cdots
  x_k^{\alpha_{i,k}}$ so we can omit $0$-coefficients. As usual, we call a monomial in $p$
  together with its coefficient a \emph{term}.
\end{definition}

\begin{figure}[tbh]
  \centering
  \begin{tikzpicture}
    \draw[->] (-0.1,0) -- (5.5,0) node[right] {$x$};
    \draw[->] (0,-0.1) -- (0,5.5) node[left] {$p(x)$};
    \begin{scriptsize}
      \foreach \x in {1, 2, 3, 4, 5}
      {
        \draw (0.1,\x) -- (-0.1,\x) node[left] {$\x$};
        \draw (\x,0.1) -- (\x,-0.1) node[below] {$\x$};
      }
    \end{scriptsize}

    \draw[dashed] (-0.05,-0.1) -- (2.75,5.5);
    \draw[dashed] (-0.1,1.9) -- (3.5,5.5);
    \draw[dashed] (-0.1,5) -- (5.5,5);
    \draw[thick] (-0.05,-0.1) -- (2,4) -- (3,5) -- (5.5,5);
  \end{tikzpicture}
  \caption{Graph of the tropical polynomial $p=x^2\oplus 2\odot x \oplus 5$}
  \label{fig:tropPolyPlot}
\end{figure}

By again translating back to the traditional operations, evaluating this polynomial at
elements in $\setR^k$ yields a function
\[
  p : \setR^k \to \setR, (x_1, \dots, x_k) \mapsto
  \min\left\{
    a_i + \sum_{j=1}^k \alpha_{i,j}x_j : 1 \leq i \leq m
  \right\}
\]
which is continuous, piecewise linear with finitely many pieces and concave, meaning that
for any $a,b \in \setR^k$ the equality $p(\frac12(a+b)) \geq \frac12(p(a)+p(a))$ holds.
Consider, for example, the polynomial $p = x^2 \oplus 2\odot x \oplus 5$ in the single
variable $x$. As we see in Figure~\ref{fig:tropPolyPlot}, each monomial of $p$ corresponds
to a linear piece of the graph and the function $p$ is in fact concave.

With the newly established notion of tropical polynomials, the next step towards defining
tropical varieties is to consider special sets $X \subseteq \setR^k$ induced by tropical
polynomials. Whereas the main object of study in classical algebraic geometry are the
roots or vanishing loci of polynomials and -- more generally -- polynomial ideals,
evaluating to zero is not a particularly interesting property of a tropical polynomial.
Similarly, evaluating to the additive identity is equally uninteresting: If $p$ is not
already the constant $\infty$-function, then $p(x)=\infty$ if, and only if, $x=\infty$.
Instead, using the fact that the induced function is piecewise linear we consider the
following set:

\begin{definition}[Tropical Hypersurface]
  \label{def:tropHypersurface}
  Let $p = \bigoplus_{i=1}^k a_i \odot x_1^{\alpha_{i,1}}\cdots x_k^{\alpha_{i,k}}$ be a
  tropical polynomial in the variables $x_1, \dots, x_k$ with induced piecewise linear
  function $p:\setR^k \to \setR$. For an element $a\in \setR^k$ the value $p(a)$ is the
  minimum over the terms of $p$; we set
  \[
    V(p) = \left\{
      a \in \setR^k :
      \text{ the minimum $p(a)$ is attained by at least two terms of $p$}
    \right\}
  \]
  and call it the \emph{tropical hypersurface} of $p$. Equivalently, a point $a\in
  \setR^k$ lies in $V(p)$ if, and only if, $p$ is not linear at $a$. With this
  interpretation in mind, the set $V(p)$ is also called the \emph{corner locus} of $p$.
\end{definition}

Again, looking at the tropical polynomial $p$ plotted in Figure~\ref{fig:tropPolyPlot}, we
see that $p$ is not linear at precisely the points $V(p) = \{ 2, 3 \}$. An interesting
property is that, by this definition, the tropical hypersurface given by a monomial
contains no points whatsoever. This will become important later on.

\begin{figure}[tbh]
  \centering
  \begin{subfigure}{0.49\textwidth}
    \centering
    \begin{tikzpicture}[scale=1.3]
      \draw[dashed, gray] (-2,0) -- (2,0);
      \draw[dashed, gray] (0,-1) -- (0,2);

      \draw[thick] (0,0) -- (-1,-1);
      \draw[thick] (0,0) -- (0,2);
      \draw[thick] (0,0) -- (2,0);
    \end{tikzpicture}
    \caption{Tropical line}
    \label{fig:trop:line}
  \end{subfigure}
  \begin{subfigure}{0.49\textwidth}
    \centering
    \begin{tikzpicture}[scale=1.3]
      \draw[dashed, gray] (-2,0) -- (2,0);
      \draw[dashed, gray] (0,-1) -- (0,2);

      \draw[thick] (-2,-1) -- (-1,0) -- (0,0) -- (1,1) -- (2,1);
      \draw[thick] (-1,0) -- (-1,2);
      \draw[thick] (0,0) -- (0,-1);
      \draw[thick] (1,1) -- (1,2);
    \end{tikzpicture}
    \caption{Tropical quadric}
    \label{fig:trop:quad}
  \end{subfigure}
  \caption{A tropical line and quadric in $\setR^2$}
  \label{fig:tropLineQuad}
\end{figure}

Since monomials and powers of variables are well-defined, we can assign a \emph{degree} to
a tropical polynomial in the usual sense, hence we may carry over the naming conventions
for hypersurfaces in standard algebraic geometry: A hypersurface given by a degree 1
polynomial is called a tropical hyperplane, for degrees 2, 3 and so on they are called
tropical quadrics and cubics respectively. For instance, in Figure~\ref{fig:trop:line} we
see the tropical line $V(x \oplus y \oplus 0)$. The tropical quadric on the right is the
corner locus of $1\otimes x^2 \oplus xy \oplus x \oplus x \oplus 1$ and will be mentioned
again later on. As a final note, since tropical division is well-defined for non-infinite
elements we may also consider tropical polynomials in negative exponents, in particular to
make sense of the tropicalization of Laurent polynomials.

\subsection{Valuations and Puiseux Series}

Most of the following definitions and algorithms will make use of fields equipped with a
non-trivial valuation:

\begin{definition} \label{def:val}
  We fix a field $K$ and recall that a \emph{valuation} is a map $\nu:K\to \setR \cup
  \{\infty\}$ that satisfies the following properties: For any $a, b \in K$ we have
  \begin{enumerate}
    \item $\nu(a) = \infty$ if, and only if, $a=0$,
    \item $\nu(ab) = \nu(a)+\nu(b)$ and
    \item $\nu(a+b) \geq \min\{\nu(a), \nu(b)\}$ with equality if $\nu(a)\neq \nu(b)$.
      \label{def:val:eq}
  \end{enumerate}
\end{definition}

A valuation is called \emph{non-trivial} if it is not the constant 0-function on $K^* =
K\setminus\{0\}$. Such a field with valuation defines a local ring $R_\nu = \{ x \in K :
\nu(x) \geq 0 \}$ with unique maximal ideal $\mathfrak m_{R_\nu} = \{ x \in K : \nu(x) > 0
\}$. The \emph{residue field} of $K$ is then defined to be the residue field $\mathfrak K
= R_\nu/\mathfrak m_{R_\nu}$ of $R_\nu$. Various fields with non-trivial valuation are
suitable for computational purposes. The one over which we will usually do our
computations is the field of Puiseux series:

\begin{definition}[Puiseux Series]
  \label{def:puiseux}
  Let $K'$ be a field. The field of \emph{Puiseux series} $K = \puiseux{K'}{t}$ with
  coefficients in $K'$ in the indeterminate $t$ is the set of all formal power series
  \begin{equation} \label{eq:puiseux1}
    f = c_1 t^{a_1} + c_2 t^{a_2} + c_3 t^{a_3} + \cdots
  \end{equation}
  with $c_k \in K'\setminus\{0\}$ for all $k \in \setN$ and rational numbers $a_1 < a_2 <
  a_3 < \cdots$ that have a common denominator. Hence, the series can be rewritten as
  \begin{equation} \label{eq:puiseux2}
    f = \sum_{k = k_0}^\infty c'_k t^{\frac kN}
  \end{equation}
  with suitable $c'_k \in K'$ for all $k\geq k_0$, $c_{k_0}'\neq0$ and the common
  denominator $N \in \setN_{>0}$.
\end{definition}

By considering the rings of formal Laurent series $\smash{K'((t^{\frac1n}))}$ for $n \in
\setN_{>0}$ in the indeterminate $\smash{t^{\frac1n}}$, we can see that
\[
  K = \puiseux{K'}t = \bigcup_{n \in \setN_{>0}} K'((t^{\frac1n})).
\]
The most important use case will involve $K'$ being algebraically closed, in particular we
usually choose $K'=\setC$. This is due to the following theorem:

\begin{theorem}[Newton-Puiseux]
  \label{thm:puisuexalgclosed}
  If $K'$ is an algebraically closed field of characteristic 0, then $K =
  \puiseux{K'}{t}$ is also algebraically closed. In particular, $K$ is the algebraic
  closure of the field of formal Laurent series $K'((t))$.
\end{theorem}

The proof of this theorem is constructive and -- provided one can compute roots over the
base field $K'$ -- yields a method to iteratively compute roots of a polynomial in
$\puiseux{K'}{t}[x]$ up to a given order, see for example the proof of
\cite[Theorem~2.1.5]{sturmMacTrop}. As we will see, finite \emph{expansions} of these
roots will suffice for our purposes. The proof cited above uses the natural valuation $\nu
: \puiseux{K'}{t} \to \setR \cup \{\infty\}$ of this field: for an element $f \in
\puiseux{K'}{t}^*$ we define $\nu(f)$ to be the lowest exponent that appears in a non-zero
term of $f$, i.e.\ $a_1$ in \eqref{eq:puiseux1} and $k_0/N$ in \eqref{eq:puiseux2}.

\begin{example} \label{ex:valuations}
  Let $L$ be any field and fix $K' = \setC$ so $K = \CCt$.
  \begin{enumerate}
    \item If we equip $L$ with the trivial valuation $\nu(L^*) = \{0\}$, then we have
      $R_\nu = L$ and $\mathfrak m_{R_\nu} = \{0\}$, so $\mathfrak K = L$.
    \item By the definitions it is clear that the residue field of the Puiseux series ring
      $\CCt$ must be $\mathfrak K = \setC$. To see this, consider $f =
      c_1t^{a_1}+c_2t^{a_2}+\cdots \in R_{\nu}$. Then since $\nu(f) \geq 0$ we have that
      $a_1 = \nu(f) \in \setQ_{\geq0}$. If $a_1 > 0$, then already $f \in \mathfrak
      m_{R_\nu}$, so $\bar f = 0 \in \mathfrak K$. Otherwise we have $a_1 = 0$ and
      $c_2t^{a_2} + \cdots \in \mathfrak m_{R_\nu}$ as $a_2 > a_1$. Thus $\bar f = \bar
      c_1 \in \mathfrak K$, showing $\mathfrak K \subseteq \setC$. But since any scalar in
      $\setC$ is already a Puiseux series with valuation 0 we get equality.
    \item The Puiseux series $t^{\frac12}, t^{\frac12} + t^{\frac23} + t^2,
      \sum_{i=1}^\infty \frac1i t^{\frac i2} \in \CCt$ all have valuation $\frac12$.
    \item We will come back to computing finite expansions of roots of univariate
      polynomials in a later section over $K = \CCt$, see
      Example~\ref{ex:zeroDimTrop}.\ref{ex:zdt2}.
  \end{enumerate}
\end{example}

In our applications later on we often want to take elements in our field and
\enquote{uniformize} them to elements in the ring $R_{\nu}$ which may then define classes
in $\mathfrak K$. Using the fact that $\nu : K^* \to (\setR, +)$ is a group homomorphism,
the following lemma shows that there always are elements of suitable valuation to achieve
this.

% also need this
\begin{lemma}[{\cite[Lemma~2.1.15]{sturmMacTrop}}]
  \label{lem:valSplit}
  Denote the valuation group of $\nu$ by $\Gamma_\nu = \nu(K^*)$. If $K$ is algebraically
  closed, then there is a group homomorphism $\psi : \Gamma_\nu \to K^*$ with
  $\nu(\psi(w)) = w$ for all $w \in \Gamma_\nu$. In other words, the surjection $\nu : K^*
  \to \Gamma_\nu$ splits.
\end{lemma}

We will denote the elements $\phi(w) \in K^*$ by $t^w$ which is motivated by our focus on
Puiseux series. In the case $K = \CCt$ we have $\Gamma_\nu = \setQ$ and $\phi(w) = t^w$.
Working in polynomial rings over $\CCt$ or similar fields with valuation mainly provides
theoretical benefits like using Newton polygons to determine valuations of roots as in
Lemma~\ref{lem:newtPolyRoots}. However, the iterative method used to prove
Theorem~\ref{thm:puisuexalgclosed} also provides a fall-back method of computing
zero-dimensional affine varieties. To this end, we usually consider elements of $\setQ(t)$
as finite approximations of Puiseux series. Methods for Puiseux expansion computations are
implemented in the \textsc{Singular} library \texttt{puiseux.lib} \cite{puiseuxLib}.

\begin{example}[$p$-adic Valuation] \label{ex:pAdic}
  On a closing note, we want to take a look at another important class of fields with
  valuation. Let $K = \setQ$ be the rational numbers and $p\in \setN$ be a prime number.
  Then for any $z \in \setQ$ there are $m, k \in \setZ$, $n \in \setN_{>0}$ such that $z =
  p^k \frac mn$ where $p$ does not divide $m$ and $n$. The integer $k$ is unique so we
  define the \emph{$p$-adic valuation $\nu_p$} by $\nu_p(z) = k$. This is indeed a
  valuation; for instance we have $\nu_2(2/3) = 1, \nu_3(2/3)=-1$ and $\nu_2(7/16)=2$.

  The local ring $R_{\nu_p}$ is the localization $\setZ_{\ideal p}$ at the prime ideal
  $\ideal p$ which is the set of rational numbers $\frac mn$ where $p \nmid n$. The
  maximal ideal $\mathfrak m_{R_{\nu_p}} \idealof R_{\nu_p}$ consists then of these
  rational numbers where $m$ is in addition divisible by $p$. From this we obtain that
  the residue field $\mathfrak K = \setZ/p\setZ$ is the finite field with $p$ elements.
\end{example}

\subsection{Gröbner Fans}
\label{sec:grobFan}

One way of looking at the tropical variety of a polynomial ideal $I \idealof K[\vec x] =
K[x_1, \dots, x_n]$ is to first consider its Gröbner fan. This fan partitions the space
$\setR^n$ or a suitable subspace thereof into polyhedral cones which contain all weight
vectors $w\in \setR^n$ that define the same initial ideal of $I$. While this fan is a
highly interesting object of study in and on itself, by restricting the fan to those cones
which correspond to monomial-free initial ideals, we obtain the tropical variety of the
given ideal.

We start off this section with some basic definitions from convex geometry which will lead
to the definition of the Gröbner fan of an ideal. This will then allow us to define
tropical varieties and demonstrate their connection to the Gröbner fan. For this we mainly
focus on definitions and results found in \cite{compGrobFan} and \cite{SturmGBCP}. The
first step towards defining a fan is to understand the very important concept of polyhedra
and polyhedral cones:

\begin{definition}[Polyhedral Cones]
  \label{def:polyhedralCone}
  Recall that a set of the form $C = \{ \vec x \in \setR^n : A\vec x \leq \vec b \}$ for
  some matrix $A \in \Mat(m\times n, \setR)$ and $\vec b \in \setR^m$ is called a
  polyhedron and if additionally $C$ is bounded it is called a polytope. If, on the other
  hand, $\vec b = 0$ then $C$ is called a \emph{polyhedral cone}. Equivalently, a
  polyhedral cone $C$ is the positive span of finitely many vectors in $\setR^n$.
\end{definition}

Note that, using linear programming, it is possible to assign a unique \emph{canonical}
set of defining equations and inequalities to a polyhedral cone. This is important to
quickly compare and uniquely identify polyhedral cones, especially in computational
contexts and is -- for instance -- achieved via the \emph{double description method}, see
for instance \cite{fuDD}.

For a polyhedron $P \subseteq \setR^n$ we further define its dimension as the dimension of
the smallest affine linear space containing $P$. Consider now an element $\vec w \in
\setR^n$, then we define the set $\face_{\vec w}(P) = \{ \vec u \in P : \vec w\cdot \vec u
\geq \vec w \cdot \vec v \text{ for all } \vec v\in P\}$ where the vector multiplication
is the standard scalar product on $\setR^n$. We call a subset of $P$ of the form
$\varnothing$ or $\face_{\vec w}(P)$ a \emph{face} of $P$. For example, the trivial faces
of $P$ are $\varnothing$ by definition and $P = \face_{\vec 0}(P)$. Clearly, a face of $P$
is a polyhedron itself and we call it a facet if it has dimension exactly one less than
$P$. The notion of faces is important for the next definition:

\begin{definition}[Polyhedral Complexes and Fans]
  \label{def:polyhedralFan}
  Let $\mathcal C$ be a collection of polyhedra in $\setR^n$. We call $\mathcal C$ a
  \emph{polyhedral complex} if
  \begin{enumerate}
    \item all non-empty faces of $P$ are in $\mathcal C$ for all $P \in \mathcal C$ and
    \item for any $P,Q \in \mathcal C$ the intersection $P\cap Q$ is a face of both $P$
      and $Q$.
  \end{enumerate}
  A polyhedral complex is \emph{pure} if all its maximal polyhedra are of the same
  dimension. The support of $\mathcal C$ is $\bigcup_{P\in\mathcal C}P$ and we call
  $\mathcal C$ a \emph{polyhedral fan} if all polyhedra in $C$ are polyhedral cones.
  Furthermore, if the support of a polyhedral fan is all of $\setR^n$ we call it
  \emph{complete}.
\end{definition}

Intuitively, a polyhedral complex is a collection of polyhedra where intersecting
arbitrary elements does not produce new polyhedra and -- more importantly -- if the
intersection of two such polyhedra is a non-trivial face of both of them, they only
\enquote{touch}. To make polyhedral complexes easier to work with we call a collection of
polyhedra a \emph{representation} of a complex $\mathcal C$ if each polyhedron $P \in
\mathcal C$ is a face of some $S \in \mathcal S$. In particular, the maximal polyhedra of
a polyhedral complex define a representation.

\begin{example}\
  \begin{enumerate}
    \item For any $n \in \setN_{>0}$ we have $\setR^n = \{ \vec x \in \setR^n : 0 \cdot
      \vec x \leq 0 \}$, so the entire ambient space is a polyhedral cone. Furthermore, it
      is clear that $\face_{\vec w}(\setR^n) = \varnothing$ for any $0\neq\vec w \in
      \setR^n$, so the only faces of $\setR^n$ are $\varnothing$ and the whole space
      itself. Thus, $\{ \varnothing, \setR^n\}$ is a pure and complete polyhedral fan,
      albeit an uninteresting one.
    \item Consider the four quadrants
      \begin{align*}
        C_0 &= \{ \vec x \in \setR^2 : x_1 \geq 0, x_2 \geq 0 \}, &
        C_1 &= \{ \vec x \in \setR^2 : x_1 \leq 0, x_2 \geq 0 \}, \\
        C_2 &= \{ \vec x \in \setR^2 : x_1 \geq 0, x_2 \leq 0 \}, &
        C_3 &= \{ \vec x \in \setR^2 : x_1 \leq 0, x_2 \leq 0 \}
      \end{align*}
      of the real plane $\setR^2$, then they are evidently polyhedral cones. Each of them
      has two out of the coordinate rays spanned by the unit vectors in the four positive
      and negative coordinate directions
      \[
        r_0 = \vectRR10 \cdot \setR,
        r_1 = \vectRR01 \cdot \setR,
        r_2 = \vectRR{-1}0 \cdot \setR
        \text{ and }
        r_3 = \vectRR0{-1} \cdot \setR
      \]
      as facets. Furthermore, $\{0\}$ is a facet of each ray and thus a face of each
      quadrant, so we get the polyhedral fan $\{ \varnothing, \{0\}, r_0, \dots, r_3, C_0,
      \dots, C_3 \}$ which is again pure and complete. The set of quadrants is a
      representation of this fan.
  \end{enumerate}
\end{example}

Now, given a polynomial ring $K[\vec x]$ a \emph{term} or \emph{monomial ordering} $\prec$
on the monomials $K[\vec x]$ is a total ordering such that $1 \prec \vec x^\alpha =
x_1^{\alpha_1}\cdots x_n^{\alpha_n}$ for all $\alpha \in \setN^n$ and if $\vec x^\alpha
\prec \vec x^\beta$ for some $\alpha, \beta \in \setN^n$ then also $\vec x^{\alpha+\gamma}
\prec \vec x^{\beta+\gamma}$ for all $\gamma \in \setN^n$. Hence we can order the non-zero
terms of any non-zero polynomial $f \in K[\vec x]$ which defines a unique maximal
\emph{initial term} $\initial_\prec(f)$. Correspondingly, for an ideal $I \idealof K[\vec
x]$ we define the \emph{initial ideal} of $I$ as $\initial_\prec(I) =
\ideal{\initial_\prec(f) : f \in I}$. Initial ideals are used to define one of the most
important concepts in computer algebra: A finite subset $\mathcal G \subseteq I$ is called
a \emph{Gröbner basis} of the ideal $I$ with respect to $\prec$ if its initial terms
$\mathcal G' = \{ \initial_\prec(g) : g \in \mathcal G \}$ generate $\initial_\prec(I)$.
Furthermore, if the elements of $\mathcal G'$ are irredundant $\mathcal G$ is called
\emph{minimal} and if for any $g, g' \in \mathcal G$ no terms of the tail $g$ are
divisible by $\initial_\prec(g')$ then $\mathcal G$ is \emph{reduced}. The \emph{tail} of
a polynomial is the sum of all non-maximal terms, that is, the tail of $f$ is
$f-\in_{\prec}(f)$. The reduced Gröbner basis of an ideal $I$ with respect to $\prec$ can
be shown to be unique up to scaling with units, so we denote it by $\mathcal G_\prec(I)$.
While there are infinitely many possible term orderings in polynomial rings with more than
one variable, one can show, using the Noetherian property of polynomial rings over fields,
that for a fixed $I \idealof K[\vec x]$ there exist only finitely many different initial
ideals.

Using this argument we are interested in grouping all term orderings into finitely many
classes, but this first requires a way to identify a given ordering with a more tangible
description. The idea is to represent term orderings by weight vectors:

\begin{definition}[Initial Forms]
  \label{def:initFormG}
  Given a $\vec w \in \setR^n$ we define the \emph{initial form} $\initial_{\vec w}(f)$ of
  $f = \sum_{\alpha\in\setN^n} c_\alpha \vec x^\alpha \in K[\vec x]$ with respect to $\vec
  w$ to be the sum of all non-zero terms $c_\alpha \vec x^\alpha$ of $f$ where $\vec
  w\cdot \alpha$ is maximal. In the same manner as above this defines an initial ideal
  $\initial_{\vec w}(I)$ for $I \idealof K[\vec x]$.
\end{definition}

Note that initial ideals of this form need not be monomial ideals -- in fact the weight
vectors for which this is not the case will be of interest later on. If necessary, this
can be fixed by introducing a \enquote{tie breaker} ordering: Given any total term
ordering $\prec$ and any weight vector $\vec w\in\setR^n$ with non-negative components, we
may define a new term ordering $\prec_{\vec w}$ by
\[
  \vec x^\alpha \prec_{\vec w} \vec x^\beta
  \quad\iff\quad
  \vec w \cdot \alpha < \vec w\cdot \beta
  \text{ or }
  \left(
    \vec w \cdot \alpha = \vec w\cdot \beta
    \text{ and }
    \vec x^\alpha \prec \vec x^\beta
  \right)
\]
where the non-negativity constraint is required to ensure that $\prec_{\vec w}$ is also a
total ordering, meaning that 1 will be smaller than any other monomial with respect to
$\prec_{\vec w}$. Among some other useful properties, the most important result obtained
from these constructions is the following:

\begin{proposition}[{\cite[Proposition~1.11]{SturmGBCP}}]
  \label{prp:init}
  For any global term ordering $\prec$ and any ideal $I \idealof K[\vec x]$ there is a
  weight vector $\vec w \in \setR^n_{\geq0}$ with $\initial_\prec(I) = \initial_{\vec
  w}(I)$.
\end{proposition}

The next step is to group these weight vectors into classes: For a given $I \idealof
K[\vec x]$ we call two weights $\vec w, \vec w' \in \setR^n$ \emph{equivalent} if
$\initial_{\vec w}(I) = \initial_{\vec w'}(I)$ and it is easy to see that this indeed
defines an equivalence relation. Denoting the corresponding equivalence classes by
\[
  C[\vec w] = \left\{
    \vec w' \in \setR^n : \initial_{\vec w'}(I) = \initial_{\vec w}(I)
  \right\},
\]
In \cite[Section~2]{compGrobFan}, it is shown that, if an equivalence class $C[\vec w]$
contains a strictly positive vector then it is a relatively open convex polyhedral cone.
This immediately leads to the following definition:

\begin{definition}[Gröbner Cones and Fans]
  \label{def:groebnerConeFan}
  Fix an ideal $I \idealof K[\vec x]$. For a weight $\vec w \in \setR^n$ with $C[\vec w]
  \cap \setR^n_{>0} \neq \varnothing$ we call the Euclidean closure $C_{\vec w}(I) =
  \overline{C[\vec w]}$ the \emph{Gröbner cone} of~$I$ with respect to $\vec w$. The
  collection of all these cones $\GF(I) = \{ C_{\vec w}(I) : \vec w \in \setR^n_{\geq0}
  \}$ is called the \emph{Gröbner fan} of $I$.
\end{definition}

In \cite[Theorem~2.19]{compGrobFan} it is shown that the Gröbner fan is in fact a fan. Its
support $\GR(I) = \{ \vec w \in \setR^n : \exists \vec w' \in \setR^n_{\geq0} :
\initial_{\vec w}(I) = \initial_{\vec w'}(I)\}$ is called the \emph{Gröbner region}
of~$I$. In \cite{SturmGBCP}, Sturmfels introduces Newton polytopes as a means to compute
the Gröbner fan of an ideal which work similarly to the polygons we will introduce in
Definition~\ref{def:newtonPoly}, but serve a different purpose. The connection to tropical
varieties will be drawn in the next section. We may also occasionally need Gröbner cones
with respect to a given term ordering. By Proposition~\ref{prp:init} for any $I \idealof
K[\vec x]$ and term order $\prec$ there is a $\vec w \in \setR^n_{\geq0}$ with
$\initial_\prec(I) = \initial_{\vec w}(I)$. Hence we define the corresponding Gröbner cone
to be $C_\prec(I) = C_{\vec w}(I)$.

To conclude this section, we present a result which warrants restricting our algorithms to
the cases of homogeneous ideals. The proof of this uses the equivalent condition for
homogeneity that for any $f \in I$ all its homogeneous components lie in $I$.

\begin{proposition}[{\cite[Proposition~1.12]{SturmGBCP}}]
  \label{prp:grRegion}
  Let $I \idealof K[\vec x]$ be a homogeneous ideal with respect to some positive grading
  $\deg(x_i) = d_i > 0$. Then $\GR(I) = \setR^n$.
  \begin{proof}
    For any $\vec w \in \setR^n$ there is a $\lambda > 0$ such that $\vec w' = \vec w +
    \lambda \vec d$ has no negative components, where $\vec d = (d_1, \dots, d_n)$. Our
    goal is to show that $\initial_{\vec w'}(I) = \initial_{\vec w}(I)$.

    If $f \in I$ is homogeneous, then it is clear that $\initial_{\vec w}(I) =
    \initial_{\vec w'}(I)$: By homogeneity the additional $\lambda \vec d$ adds an equal
    amount to each term, so being maximal with respect to $\vec w$ is equivalent to to
    being maximal with respect to $\vec w'$. If $f \in I$ is not homogeneous, then we
    write $f = f_1 + \cdots + f_r$ for the homogeneous components $f_1,\dots,f_r$. In
    particular, as noted above we have $f_1, \dots, f_r \in I$. As each term of $f$ is a
    term of a unique $f_i$, each term of $\initial_{\vec w}(f)$ is a term of some
    $\initial_{\vec w}(f_i)$. Hence there is a subset $\{i_1, \dots, i_s\} \subseteq \{1,
    \dots, r\}$ such that $\initial_{\vec w}(f) = \initial_{\vec w}(f_{i_1}) + \cdots +
    \initial_{\vec w}(f_{i_s})$. Since these initial forms lie in $\initial_{\vec w'}(I)$
    by the above, we have $\initial_{\vec w}(I) \subseteq \initial_{\vec w'}(I)$. The same
    argument with $\vec w$ and $\vec w'$ exchanged shows the reverse inclusion.
  \end{proof}
\end{proposition}

In particular, any arbitrary weight $\vec w \in \setR^n$ lies in a convex equivalence
class with respect to a homogeneous ideal $I$.

\subsection{Tropical Varieties}
\label{sec:tropVar}

After this light introduction to tropical arithmetic and some convex geometry, we now shift
our focus to more general polynomials and ideals. The idea is to combine the fan structure
of the Gröbner fan we derived in Section~\ref{sec:grobFan} with our knowledge on tropical
hypersurfaces from Section~\ref{sec:tropIntro}. Here we will introduce the general
procedure of computing a tropical variety by computing cones in the corresponding fan and
finding its neighbor cones.

We fix a field $K$ which usually admits a non-trivial valuation $\nu : K \to \setR \cup
\{\infty\}$. The usual setting is to consider the \emph{Laurent polynomial} ring $K[\vec
x^{\pm1}] = K[x_1^{\pm1}, \dots, x_n^{\pm1}]$ -- the ring of polynomials in $x_1, \dots,
x_n$ with integral but not necessarily non-negative exponents. Ideals and polynomials in
this ring define zero loci much in the same manner as for standard polynomial rings,
however, as monomials are now invertible, evaluation at zero is no longer well-defined. As
such, we consider the \emph{very affine variety}\footnote{This name is mainly used in
\cite{sturmMacTrop} and does not appear to be standard nomenclature.} of an ideal $I
\idealof K[\vec x^{\pm1}]$ as a subset of the \emph{algebraic torus} $\setT^n = {(K^*)}^n
= {(K \setminus \{0\})}^n$:
\[
  X = V(I) = \left\{ a \in \setT^n : f(a) = 0 \text{ for all $f \in I$} \right\}.
\]
Note that we may turn $K[\vec x^{\pm1}]$ into a standard polynomial quotient ring by
considering $K[x_1,x_1^{-1}, \dots, x_n,x_n^{-1}]$, where $x_i, x_i^{-1}$ are unrelated
ring variables and mod out the relations $x_i\cdot x_i^{-1} = 1$ for all $i=1,\dots,n$.
In other words, for the ideal
\[
  I = \ideal{ x_ix_i^{-1}-1 : i = 1, \dots, n}
\]
we have $K[\vec x^{\pm1}] \cong K[x_1,x_1^{-1}, \dots, x_n,x_n^{-1}]/I$ and hence $\setT^n
\cong V(I) \subseteq \setA^{2n}$ may be viewed as an affine variety.

In this setting -- although not limited to Laurent polynomials -- we now want to study
initial ideals. To define them in a useful way, we first need to establish a link between
classical and tropical polynomials: this is where the valuation $\nu:K\to\setR$ will be
used.

\begin{definition}[Tropicalization and Initial Forms]
  \label{def:initialId}
  Let $f \in K[\vec x^{\pm1}]$ be a Laurent polynomial and $\nu : K \to \setR$ a valuation
  as in the above setting. Write $f = \sum_{\alpha \in \setZ^n} c_\alpha \vec x^\alpha$,
  then the \emph{tropicalization} $\trop(f)$ of $f$ is the tropical polynomial
  \[
    \trop(f) = \bigoplus_{\alpha\in\setZ^\alpha} \nu(c_\alpha)
    \odot x_1^{\alpha_1}\odot\cdots \odot x_n^{\alpha_n}
  \]
  which defines a function $\trop(f) : \setR^n \to \setR, \vec w \mapsto \trop(f)(\vec w)$
  in the usual manner. For a weight vector $\vec w \in \setR^n$ we now define the
  \emph{initial form} of $f$ with respect to $\vec w$ as
  \[
    \initial_{\vec w}(f) =
    \sum_{ \substack{
        \alpha \in \setZ^n \\
        \nu(c_\alpha) + \vec w\cdot \alpha = \trop(f)(\vec w)
    }} \overline {c_\alpha \cdot t^{-\nu(c_\alpha)} } \vec x^\alpha
    \in \mathfrak K[\vec x^{\pm1}]
  \]
  where $\overline{c}$ denotes the image of an element $c \in K$ with $\nu(c)\geq0$ in the
  residue field $\mathfrak K = R_\nu/\mathfrak m_{R_\nu}$ and recall the notation $t^z$
  introduced by Lemma~\ref{lem:valSplit}. In other words, $\initial_{\vec w}(f)$ consists
  of all the terms $c_\alpha\cdot \vec x^\alpha$ of $f$ where $\nu(c_\alpha)+\vec w\cdot
  \alpha$ is minimal. Again, $\initial_{\vec w}(f)$ need not be a monomial.
\end{definition}

We note here that the notations from Definitions~\ref{def:initFormG} and
\ref{def:initialId} clash. However, when working over a field with trivial valuation,
meaning $\nu(x) = 0$ for all units $x \in K^*$, then they only differ in maximizing and
minimizing the linear form $\vec w$. In fact, it is common to consider initial ideals
which maximize $\vec w$ in Gröbner basis theory as they more closely resemble the ones
given by total term orderings. In the tropical setting however, one usually minimizes
the weight. While we chose to adhere to the minimum-convention in order to remain
consistent with the cited literature, it is not difficult to switch between the two
notions: It suffices to switch all instances of \enquote{minimum} to \enquote{maximum} and
to alter the definition of tropical arithmetic accordingly. In the following,
$\initial_{\vec w}(\cdot)$ will always refer to the initial ideals as defined in
Definition~\ref{def:initialId}.

To make our notion of a weight ordering $\prec_{\vec w}$ consistent with this convention,
we redefine $\prec_{\vec w}$ to be the ordering $\prec_{-\vec w}$ as introduced in
Section~\ref{sec:grobFan}. In the case where $\nu$ is trivial, this ensures matching
behavior: If $\initial_{\vec w}(f)$ is a monomial for some polynomial $f$, then
$\initial_{\prec_{\vec w}}(f) = \initial_{\vec w}(f)$ and otherwise $\initial_{\prec_{\vec
w}}(f)$ is the maximal term of $\initial_{\vec w}(f)$ with respect to $\prec$. This is not
true in general for the original definition as it maximizes the linear form~$\vec w$.

With these potential inconsistencies out of the way, we are now finally able to define
tropical varieties, the main object of study of this thesis:

\begin{definition}[Tropical Varieties and Prevarieties]
  \label{def:tropicalVariety}
  Let $f \in K[\vec x^{\pm1}]$ be a polynomial over a field with valuation as above, then
  its \emph{tropical hypersurface} is the set
  \[
    \Trop(f) = \left\{
      \vec w \in \setR^n :
      \text{the minimum $\trop(f)(\vec w)$ is achieved twice}
    \right\}
  \]
  and using Definition~\ref{def:tropHypersurface}, this may be simply written as $\Trop(f)
  = V(\trop(f))$. A \emph{tropical prevariety} is the finite intersection of tropical
  hypersurfaces. Finally, for an ideal $I \idealof K[\vec x^{\pm1}]$ the \emph{tropical
  variety} of $I$ is defined to be the set
  \[
    \Trop(I) = \bigcap_{f \in I} \Trop(f).
  \]
\end{definition}

% change first sentence
The main motivation in \cite{compTropVar} is the fact that each tropical variety is in
fact a tropical prevariety: A finite set $\{ f_1, \dots, f_r \} \subseteq I \idealof
K[\vec x^{\pm1}]$ is called a \emph{tropical basis} of $I$ if $I = \ideal{f_1, \dots,
f_r}$ and $\Trop(I) = \Trop(f_1) \cap \cdots \cap \Trop(f_r)$. It can be shown that any
ideal admits a tropical basis -- see for example \cite[Theorem~2.9]{compTropVar} -- which
reduces the problem of computing the tropical variety of an ideal to computing the
tropical hypersurfaces of its tropical basis. However, our approach to their computation
requires a different but equivalent description of tropical varieties. This will then in
turn allow us to equip the tropical variety with the structure of a polyhedral fan or --
in the more general cases -- of a polyhedral complex. The following theorem gives the
important characterizations for the easier case of tropical hypersurfaces:

\begin{theorem}[Kapranov's Theorem]
  \label{thm:kapranov}
  Fix an algebraically closed field with valuation, then for a $f \in K[\vec x^{\pm1}]$
  the following sets coincide:
  \begin{enumerate}
    \item the tropical hypersurface $\Trop(f)$ in $\setR^n$,
      \label{thm:kap:i}
    \item the set $\{ \vec w \in \setR^n : \initial_{\vec w}(f) \text{ is not a
      monomial}\}$
      \label{thm:kap:ii}
    \item the Euclidean closure in $\setR^n$ of the set $\{ (\nu(y_1), \dots, \nu(y_n)) :
      (y_1,\dots,y_n) \in V(f) \}$.
      \label{thm:kap:iii}
  \end{enumerate}
  \begin{proof}
    We want to sketch the \enquote{easy} parts of this proof: Suppose $\vec w \in
    \Trop(f)$, then there are two terms $c_1 \vec x^{\alpha_1}$, $c_2 \vec x^{\alpha_2}$
    of $f$ such that
    \[
      \trop(f)(\vec w) = \nu(c_1) + \vec w \cdot \alpha_1 = \nu(c_2) + \vec w \cdot \alpha_2.
    \]
    But then by Definition~\ref{def:initialId} the two corresponding terms
    $\overline{\nu(c_i)t^{-\nu(c_i)}\vec x^{\alpha_i}}$ for $i=1,2$ occur in the initial
    form $\initial_{\vec w}(f)$, so it cannot be a monomial. Similarly, if we take $\vec
    w$ from set \ref{thm:kap:ii}, then $\initial_{\vec w}(f)$ is not a monomial and by
    definition the minimum $\trop(f)(\vec w)$ is achieved twice. Thus sets \ref{thm:kap:i}
    and \ref{thm:kap:ii} agree.

    We show one of the remaining inclusions: \ref{thm:kap:iii} $\subseteq$
    \ref{thm:kap:i}. As $\Trop(f)$ is a closed set, we only need to show the inclusion for
    $\vec w \in \nu(V(f))$. Suppose $\vec w \in \nu(V(f))$ with some $\vec y \in \setT^n$
    such that $f(\vec y) = 0$, where $f = \sum_{\alpha \in \setZ^n} c_\alpha \vec
    x^\alpha$. Then
    \[
      \nu \left( \sum_{\alpha \in \setZ^n} c_\alpha \vec y^\alpha \right) = \nu(0) =
      \infty > \nu(c_\alpha \vec y^\alpha)
    \]
    for all $\alpha \in \setZ^n$ with $c_\alpha \neq 0$. By iteratively applying
    Definition~\ref{def:val}.\ref{def:val:eq} this implies that at least two terms
    $c_\alpha \vec y^\alpha$ have the same valuation. Hence the minimum $\trop(f)(\vec w)$
    is achieved by the two corresponding terms, so $\vec w \in \Trop(f)$. The reverse
    inclusion is quite a bit more involved and is proved in
    \cite[Proposition~3.1.5]{sturmMacTrop}.
  \end{proof}
\end{theorem}

In particular, the tropical hypersurface of a monomial is empty. This makes sense since
the corner locus of a tropical monomial is empty as was previously stated.
Theorem~\ref{thm:kapranov} naturally generalizes to full tropical varieties without having
to alter the result in any way:

\begin{theorem}[Fundamental Theorem of Tropical Geometry,
  {\cite[Theorem~3.2.5]{sturmMacTrop}}] \label{thm:fundamentalThm}
  Let $K$ be an algebraically closed field with non-trivial valuation, $I \idealof K[\vec
  x^{\pm1}]$ and $X = V(I) \subseteq \setT^n$ its very affine variety in the affine torus,
  then the following three subsets of $\setR^n$ coincide:
  \begin{enumerate}
    \item the tropical variety $\Trop(I)$ as defined in
      Definition~\ref{def:tropicalVariety},
    \item the set of all $\vec w \in \setR^n$ with $\initial_{\vec w}(I) \neq \ideal1$,
      i.e.\ the initial ideals which do not contain monomials and
    \item \label{thm:fund:val}
      the Euclidean closure of the set of coordinate-wise valuations of points in $X$
      \[
        \nu(X) = \{ (\nu(y_1), \dots, \nu(y_n)) : (y_1, \dots, y_n) \in X \}.
      \]
  \end{enumerate}
\end{theorem}

With these equivalent descriptions of tropical varieties established we have to discuss a
technical detail relating to the upcoming sections. Until now we worked with ideals in the
Laurent polynomial ring $K[\vec x^{\pm1}]$. However, we usually want to consider ideals in
a standard polynomial ring $K[\vec x]$ as these rings are more suited for Gröbner basis
computations. In fact, starting with an $I \idealof K[\vec x]$,
Definition~\ref{def:tropicalVariety} and Theorem~\ref{thm:fundamentalThm} work in exactly
the same way. Considering the ideal $I' \idealof K[\vec x^{\pm1}]$ generated by the
elements of~$I$, it is easy to see that $\Trop(I) = \Trop(I')$: If $\vec w \not\in
\Trop(I')$ then there is a polynomial $f \in I'$ such that $\initial_{\vec w}(f)$ is a
monomial. Then there is a monomial $m \in K[\vec x]$ such that $mf \in I$ and
$\initial_{\vec w}(mf)$ is a monomial as well, so $\vec w \not\in \Trop(I)$, see also the
paragraph after the proof of \cite[Corollary~3.3]{compTropVar}. This allows us to consider
ideals in either $K[\vec x]$ or $K[\vec x^{\pm1}]$ and for most purposes we will restrict
ourselves to $K[\vec x]$ -- in particular when Gröbner basis computations are required.

Since the corner locus of a single tropical polynomial is the union of (bounded)
intersections of affine hyperplanes, it not hard to imagine that a tropical variety comes
equipped with polyhedral structures. The following theorem makes this intuition more
formal and finally allows us to tackle the problem of computing tropical varieties with
polyhedral methods:

\begin{theorem}[{\cite[Theorem~3.5.1]{sturmMacTrop}}]
  \label{thm:tropComplexConn}
  Let $I \idealof K[\vec x^{\pm1}]$ be an ideal with irreducible variety $X = V(I)
  \subseteq \setT^n$ of dimension $d$ over an algebraically closed field $K$. Then
  $\Trop(I)$ is the support of a pure $d$-dimensional polyhedral complex that is connected
  in codimension one.
\end{theorem}

More generally, if $I \idealof K[\vec x^{\pm1}]$ is prime, respectively its variety $V(I)$
is irreducible, then we call $\Trop(I)$ irreducible as well. Note again that, if we start
with a prime ideal $I \idealof K[\vec x]$ then the ideal generated over $K[\vec x^{\pm1}]$
will also be prime. Hence, the above theorem is still applicable if we start in $K[\vec
x]$. It is important to note the fan structure imposed on a tropical variety in this way
is not unique, but for our purposes the most suitable. Moreover, \enquote{connected in
codimension one} means that for any two maximal polyhedra $P, Q$ in the corresponding
complex there is a sequence of maximal polyhedra $P = P_0, P_1, \dots, P_r = Q$ such that
$P_{i-1}$ and $P_i$ share a facet for all $i = 1, \dots, r$. This important fact ensures
that, by successively computing neighboring polyhedra we will eventually find all maximal
ones.

\begin{example}
  \label{ex:notFan}
  Consider the polynomial $f = tx^2 + x + y + xy + t \in \CCt[x,y]$ and weights $\vec w =
  (1,1), \vec w' = (2,2) = 2 \vec w$. Then the respective tropicalizations evaluate to
  \begin{align*}
    \trop(f)(\vec w) &= \min \{ 1 + 2, 0 + 1, 0 + 1, 0 + 2, 1 + 0 \} = 1 \quad
    \text{and} \\
    \trop(f)(\vec w') &= \min \{ 1 + 4, 0 + 2, 0 + 2, 0 + 4, 1 + 0 \} = 1.
  \end{align*}
  We in particular see that $\initial_{\vec w}(f) = x+y+1 \in \setC[x,y]$ and
  $\initial_{\vec w'}(f) = 1$, so $\vec w \in \Trop(f)$ but $\vec w' \not\in \Trop(I)$.
  The corresponding tropical curve $V(1\odot x^2 \oplus x \oplus y \oplus xy \oplus 1)$ is
  depicted in Figure~\ref{fig:trop:quad}.
\end{example}

Theorem~\ref{thm:tropComplexConn} states that a tropical variety is the support of a
polyhedral complex which in general contains both bounded and unbounded faces. As
Example~\ref{ex:notFan} illustrates $\Trop(f)$ is not the support of a polyhedral fan, as
$(1,1) \in \Trop(f)$ but $(2,2) \not\in \Trop(f)$. Hence, any cone containing $(1,1)$ must
also contain $(2,2)$ and is thus not contained in $\Trop(f)$. However, for computational
reasons it is favorable to work with cones and polyhedral fans. In our case, where $K =
\CCt$, there are two ways to amend this issue depending on our input ideal:
\begin{enumerate}[label=\arabic*.]
  \item If we already start out in the \emph{constant coefficient case}, that is, the
    ideal $I \idealof \CCt[\vec x]$ is generated by elements of $\setC[\vec x]$, then for
    $f \in I$ the initial form $\initial_{\vec w}(f)$ will be just the minimal terms with
    respect to $\vec w$. As in Section~\ref{sec:grobFan}, this ensures that $\Trop(I)$ is
    the support of a subfan of the Gröbner fan. See also
    \cite[Remark~2.5.11]{sturmMacTrop} on the connection between general Gröbner complexes
    and fans. Note that the current implementation in \texttt{tropicalNewton.lib}
    \cite{tropNewtLib} is designed in this way and handles only the constant coefficient
    case for initial ideals.
  \item If the ideal $I\idealof\CCt[\vec x]$ in turn has \emph{non-constant coefficients},
    assume for simplicity that $I \idealof \setC(t)[x_1, \dots, x_n]$ with $I'$ being the
    ideal it generates in $\CCt[x_1, \dots, x_n]$ and $\Trop(I') \subseteq \setR^n$. We
    may instead look at the subring $R = \setC[t, x_1, \dots, x_n]$ of $\CCt[x_1, \dots,
    x_n]$ and set $J = I\cap R$. Then \cite[Lemma~1.1]{compTropVar} tells us that a weight
    $\vec w \in \setR^n$ lies in the polyhedral complex $\Trop(I')$ if, and only if, the
    weight $(1,\vec w) \in \setR^{n+1}$ lies in the polyhedral fan $\Trop(J)$. This allows
    us to transform our problems accordingly and to restrict our algorithms to working
    with polyhedral cones and fans.
\end{enumerate}
In addition to this, we are also allowed to restrict our theory and methods to tropical
varieties given by homogeneous ideals: We fix $I\idealof K[x_1, \dots, x_n]$ and a weight
$\vec w \in \setR^n$, and then consider the \emph{homogenization} $I^h \idealof K[x_0,
\dots, x_n]$ of $I$. Then \cite[Lemma~2.2]{compTropVar} states that the initial ideal
$\initial_{\vec w}(I)$ contains a monomial if, and only if, $\initial_{(0,\vec w)}(^hI)$
contains a monomial. This restriction allows us to utilize techniques specialized to
homogeneous ideals, which have been studied to great detail and are usually easier to do
calculations with. Also, as shown in Proposition~\ref{prp:grRegion}, there are no
restrictions on the Gröbner region of $I$. Hence, for the following algorithms we will
assume that every ideal $I \idealof K[\vec x]$ has constant coefficients and is
homogeneous.

With these simplifications in mind, it is clear that a tropical variety is the support of
a subfan of the Gröbner fan from Definition~\ref{def:groebnerConeFan}. We thus want to
establish the connection between the Gröbner cones contained in a tropical variety and the
Gröbner bases they define. Fixing a total monomial ordering $\prec$ as a \enquote{tie
breaker}, we usually represent a Gröbner cone $C_{\vec w}(I)$ by the pair $(\mathcal
G_{\prec_{\vec w}}(\initial_{\vec w}), \mathcal G_{\prec_{\vec w}}(I))$ of reduced Gröbner
bases, where $\vec w$ is some weight in the relative interior of the cone $C_{\vec w}(I)$.
The following lemma, used in the proof of \cite[Proposition~2.3]{SturmGBCP}, describes how
we can deduce defining equations for the Gröbner cone from the Gröbner bases themselves:

\begin{lemma}[{\cite[Lemma~4.2]{compTropVar}}]
  \label{lem:grConEq}
  Let $I \idealof K[\vec x]$ be a homogeneous ideal, $\prec$ some term ordering as above
  and $\vec w \in \setR^n$ a weight vector. For any other weight $\vec w' \in \setR^n$.
  Then
  \[
    \vec w' \in C_{\vec w}(I) \iff
    \forall f \in \mathcal G_{\prec_{\vec w}}(I) :
    \initial_{\vec w}(\initial_{\vec w'}(f)) = \initial_{\vec w}(f).
  \]
\end{lemma}

We now come to the main algorithms needed to compute tropical varieties. While
intersections of tropical hypersurfaces are required in Algorithms~\ref{alg:neighbors} and
\ref{alg:traversal} as they are formulated in \cite[Section~4]{compTropVar}, our
modifications presented in Section~\ref{sec:newtonMethod} will eliminate the dependency on
performing such intersections. Still, we want to give a short account on the general idea
behind this: Given two tropical varieties, represented by fans $\mathcal F_1$ and
$\mathcal F_2$, we define their \emph{common refinement} to be $\mathcal F_1 \wedge
\mathcal F_2 = \{ C_1 \cap C_2 : C_1 \in \mathcal F_1, C_2 \in \mathcal F_2 \}$. This is
again a fan and clearly the support of $\mathcal F_1 \wedge \mathcal F_2$ is the
intersection of the supports of $\mathcal F_1$ and $\mathcal F_2$. Also, by considering
representations of the respective fans we obtain a representation of the common refinement
in the following way. Note that, in practice, we canonicalize the resulting intersection
cones, allowing us to easily check for duplicates:

\begin{algo}[Common Refinement, {\cite[Algorithm~4.4]{compTropVar}}]\
  \label{alg:fanRefinement}
  \begin{algorithmic}[1]
    \Require Representations $S_1$, $S_2$ of two polyhedral fans $\mathcal
      F_1$, $\mathcal F_2$.
    \Ensure Representation $S$ for common refinement $\mathcal F_1 \wedge \mathcal F_2$.
    \State $S := \varnothing$
    \For{$(C_1, C_2) \in S_1 \times S_2$}
      \State Set $S := S \cup \{ C_1 \cap C_2 \}$.
    \EndFor
    \State\textbf{return} $S$
  \end{algorithmic}
\end{algo}

The main use of this algorithm is the combination of Theorem~\ref{thm:tropComplexConn}
with the fact that any tropical variety is a tropical prevariety. In particular if
$\Trop(I) = \Trop(f_1) \cap \cdots \cap \Trop(f_r)$ for some prime ideal $I$ and
polynomials $f_1, \dots, f_r$ where the corresponding hypersurfaces are known, then
successively applying Algorithm~\ref{alg:fanRefinement} will yield a representation of the
fan whose support is $\Trop(I)$. While computing a tropical hypersurface is a
comparatively easy task by considering the \emph{Newton polytope} of a polynomial (see
\cite[Algorithm~4.3]{compTropVar}), the following algorithm exploits properties of
tropical varieties which are (combinatorially) curves. As this part of the traversal
algorithm will be replaced by our algorithm involving tropical links, it will only be
provided as a \enquote{blackbox} for context.

\begin{algo}[Tropical Basis of a Curve, {\cite[Algorihm~4.8]{compTropVar}}]\
  \label{alg:tropBasisCurve}
  \begin{algorithmic}[1]
    \Require A finite set $\mathcal G$ which generates $I$, with $\Trop(I)$ being
      (combinatorially) a curve.
    \Ensure A tropical basis of $I$.
  \end{algorithmic}
\end{algo}

Another important step needed to compute neighbouring maximal Gröbner cones is computing
Gröbner bases corresponding to said cones. Obviously, it is possible to simply compute
these from scratch. However, the following \emph{lift} algorithm greatly simplifies this
procedure, as reduced Gröbner bases in the original Gröbner cone are already known. It is
a step in the \emph{Gröbner walk} \cite{groebWalk}, which transforms a Gröbner basis with
respect to a given ordering to a basis of of an ordering of an adjacent Gröbner cone. In
fact, we use a modified version of this, which is based on the results in
\cite[Proposition~3.2]{genericWalk}.

\begin{algo}[Lift]\
  \label{alg:lift}
  \begin{algorithmic}[1]
    \Require Reduced Gröbner bases $\mathcal G_{\prec'}(I)$ and $\mathcal G_{\prec_{\vec
      u}}(\initial_{\vec u}(I))$ where $\vec u \in C_{\prec}(I)\cap C_{\prec'}(I)$ for
      some term orders $\prec$ and $\prec'$.
    \Ensure Reduced Gröbner basis $\mathcal G_{\prec_{\vec u}}(I)$.
    \For{$f \in \mathcal G_{\prec_{\vec u}}(\initial_{\vec u}(I))$}
      \State Compute the remainder $f^G$ of dividing $f$ by $G =  \mathcal G_{\prec'}(I)$.
    \EndFor
    \State Set $G' = \{ f-f^G : f \in \mathcal G_{\prec_{\vec u}}(\initial_{\vec u}(I)) \}$.
    \For{$f \in G'$}
      \State Reduce $f := f^{G'\setminus\{f\}}$ as defined above.
    \EndFor
    \State \textbf{return} $G'$.
  \end{algorithmic}
\end{algo}

The proof of \cite[Proposition~3.2]{genericWalk} automatically proves the correctness of
this algorithm. The tropical curves important for the following algorithm are the
so-called \emph{tropical links}, which we will revisit in greater detail in
Section~\ref{sec:newtonMethod}. Fix a maximal Gröbner cone $C \subseteq \Trop(I)$: If
$\vec w$ is a weight contained in the relative interior of a facet $F$ of $C$, then
$\Trop(\initial_{\vec w}(I))$ is a tropical (combinatorial) curve which provides a local
description of the full tropical variety $\Trop(I)$, with each ray pointing towards a
maximal Gröbner cone containing $F$. Combining this fact with the lift algorithm yields
the following method to determine all neighboring maximal Gröbner cones of some given
maximal cone in the tropical variety:

\begin{algo}[Neighbors, {\cite[Algorithm~4.10]{compTropVar}}]\
  \label{alg:neighbors}
  \begin{algorithmic}[1]
    \Require Pair $(\mathcal G_{\prec_{\vec w}}(\initial_{\vec w}(I)), \mathcal
      G_{\prec_{\vec w}}(I))$ such that $\initial_{\vec w}(I)$ is monomial-free and
      $C_{\vec w}(I)$ has dimension $d$.
    \Ensure The set $N$ of pairs $(\mathcal G_{\prec_{\vec w'}}(\initial_{\vec w'}(I)),
      \mathcal G_{\prec_{\vec w'}}(I))$ where $\vec w'$ lies in the relative interior of
      each $d$-dimensional Gröbner cone in $\Trop(I)$ that shares a facet with $C_{\vec
      w}(I)$.
    \State Set $N := \varnothing$.
    \State Compute the set $\mathcal F$ of facets of $C_{\vec w}(I)$.
    \For{$F \in \mathcal F$}
      \State Compute initial ideal $J := \initial_{\vec u}(I)$ for a point $\vec u$ in the
        relative interior of $F$.
        \label{alg:neigh:line:start}
      \State Use Algorithms~\ref{alg:fanRefinement} and \ref{alg:tropBasisCurve} to compute
        a relative interior point $\vec v$ of each ray in the curve $\Trop(J)$. Denote by
        $V$ the set of these points.
        \label{alg:interiorPoints}
      \For{$\vec v \in V$}
        \State Compute $(\mathcal G_{\prec_{\vec v}}(\initial_{\vec v}(J)), \mathcal
          G_{\prec_{\vec v}}(J)) = (\mathcal G_{{\prec_{\vec v}}_{\vec u}}(\initial_{\vec
          v}(J)), \mathcal G_{{\prec_{\vec v}}_{\vec u}}(J))$.
        \State Apply Algorithm~\ref{alg:lift} to $\mathcal G_{\prec_{\vec w}}(I)$ and
          $\mathcal G_{{\prec_{\vec v}}_{\vec u}}(J)$ to get $\mathcal G_{{\prec_{\vec
          v}}_{\vec u}}(I)$.
        \State Set $N := N \cup \left\{ (\mathcal G_{{\prec_{\vec v}}_{\vec
          u}}(\initial_{\vec v}(I)), \mathcal G_{{\prec_{\vec v}}_{\vec u}}(I))
          \right\}$.
      \EndFor\label{alg:neigh:line:end}
    \EndFor
    \State\textbf{return} $N$.
  \end{algorithmic}
\end{algo}

We now have a method to determine neighboring maximal cones of a given Gröbner cone and
know by Theorem~\ref{thm:tropComplexConn} that the tropical variety of a prime ideal is
connected in codimension one. Thus, it is obvious how to combine our results into a full
\emph{traversal} of the tropical variety: If we can determine a maximal starting cone,
then we simply compute all neighbors of all known cones until we no longer obtain any new
neighbors. Clearly, this procedure is applicable to any polyhedral fan connected in
codimension one:

\begin{algo}[Traversal of an Irreducible Tropical Variety]\
  \label{alg:traversal}
  \begin{algorithmic}[1]
    \Require A Gröbner cone represented as $(\mathcal G_{\prec_{\vec w}}(\initial_{\vec
      w}(I)), \mathcal G_{\prec_{\vec w}}(I))$ such that $\initial_{\vec w}(I)$ is
      monomial free and has dimension $d:=\dim(I)$.
    \Ensure Collection of pairs $(\mathcal G_{\prec_{\vec w'}}(\initial_{\vec
      w'}(I)), \mathcal G_{\prec_{\vec w'}}(I))$ where $\vec w'$ are taken from the
      relative interior of each $d$-dimensional Gröbner cone contained $\Trop(I)$. The
      union of $C_{\vec w'}(I)$ for all these $\vec w'$ is $\Trop(I)$.
    \State Set $T = \{ (\mathcal G_{\prec_{\vec w}}(\initial_{\vec
      w}(I)), \mathcal G_{\prec_{\vec w}}(I)) \}$.
    \State Set $Old := \varnothing$.
    \While{$T \neq Old$}
      \State Set $Old := T$.
      \State Set $T := T \cup \mathrm{Neighbors}(T)$.
    \EndWhile
    \State\textbf{return} $T$.
  \end{algorithmic}
\end{algo}

This formulation suffices to illustrate the method of traversing a tropical variety for
now. In the next section we will look at new algorithms to improve our Neighbor-algorithm
and introduce an algorithm to compute a starting Gröbner cone. In
Section~\ref{sec:traverseParal} we will revisit the traversal algorithm and make it more
suitable for our parallelization purposes.

\subsection{Newton Polygon Method}
\label{sec:newtonMethod}

We focus on a new approach introduced by Yue Ren and Tommy Hofmann which uses Newton
polygons to compute zero-dimensional tropical varieties \cite{tropPointsLinks}. While the
general traversal procedures are given in Section~\ref{sec:tropVar}, we now want to study
different methods for computing non-trivial points in the tropical variety and links
between cones in it, which allow us to generate a starting and neighbor cones more
efficiently. In particular, Ren and Hofmann's methods provide local optimizations to the
algorithms discussed in the previous section. For this we again fix an algebraically
closed field $K$ with non-trivial valuation $\nu:K\to\setR \cup \{\infty\}$ and
residue field $\mathfrak K$.

Until now, we mainly dealt with tropical varieties as finite intersections of tropical
prevarieties or the set of all weight vectors that define monomial-free initial ideals. In
contrast, the focus of this section and our main algorithms will be the interpretation as
the coordinate-wise image $\Trop(I) = \nu(V(I))$ as we have seen in
Theorem~\ref{thm:fundamentalThm}. The main idea behind Ren and Hofmann's results is to
apply this interpretation to zero-dimensional ideals and their triangular decompositions:

\begin{definition}
  \label{def:triangSet}
  A set of polynomials $\{ f_1, \dots, f_n \} \subseteq K[x_1, \dots, x_n]$ is called a
  \emph{triangular set} if
  \[
    f_i \in K[x_1, \dots, x_i] / K[x_1, \dots, x_{i-1}]
  \]
  for each $i \in \{1, \dots, n\}$.
\end{definition}

Zero loci of ideals generated by triangular sets can be computed very easily as only
univariate methods and substitution are required. It is thus important to be able to
reduce general zero-dimensional ideals to triangular sets:

\begin{proposition}[{\cite[Corollary~4.7.4]{singIntro}}]
  Let $I \idealof K[\vec x]$ be a zero-dimensional ideal, then there exist triangular sets
  $F_1, \dots, F_s \subseteq K[\vec x]$ such that
  \begin{enumerate}
    \item $\sqrt I = \bigcap_{i=1}^s \sqrt{\ideal{F_i}}$ and
    \item $\ideal{F_i} + \ideal{F_j} = \ideal1$ for any $i\neq j$.
  \end{enumerate}
  The collection $F_1, \dots, F_s$ is called a \emph{triangular decomposition} of $I$.
  \label{prp:triang}
\end{proposition}

In particular, we have $V(I) = V(F_1) \dotcup \cdots \dotcup V(F_s)$ for a triangular
decomposition $F_1, \dots, F_s$, allowing us to easily determine roots of a
zero-dimensional ideal $I$. Note that a primary decomposition of an ideal always yields a
triangular decomposition, but, as \cite[Lemma~4.7.5]{singIntro} illustrates, this is not
the most efficient method of obtaining one. Moreover, we are actually only interested in
the valuations of the roots of univariate polynomials over $K$ due to
Theorem~\ref{thm:fundamentalThm}.\ref{thm:fund:val}. Luckily, there is a way to determine
these without needing to explicitly compute any roots. For this, we study the Newton
polygon of a polynomial:

\begin{definition}[Newton Polyon]
  Let $f \in K[x_k]$ be a univariate polynomial of the form $f = \sum_{i=0}^d c_i x_k^i$
  for $c_0, \dots, c_d \in K$. The \emph{Newton polygon} or \emph{extended Newton
  polyhedron} is defined as
  \[
    \Delta(f) = \conv \left(
      \left\{ (i, \nu(c_i)) : i = 0, \dots, d \right\}
      \cup \{ (0, \infty) \}
    \right)
    \subseteq \setR^2
  \]
  with $\conv(\cdot)$ being the convex hull of the given set. Similarly, for a
  multivariate polynomial $f \in K[x_1, \dots, x_k]$ written as $f = \sum_{i=0}^d f_i
  \cdot x_k^i$ for some $f_0, \dots, f_d \in K[x_1, \dots, x_{k-1}]$ and a weight $\vec w
  \in \setR^{k-1}$, the \emph{expected Newton polygon} of $f$ at $\vec w$ is defined to be
  \[
    \Delta_{\vec w}(f) = \conv\left(
      \left\{ (i, \trop(f_i)(\vec w)) : i = 0, \dots, d \right\}
      \cup \{ (0, \infty) \}
    \right).
  \]
  Finally, $f$ has a \emph{unique Newton polygon} at $\vec w$ if the initial form
  $\initial_{\vec w}(f)$ is a monomial for all vertices $(i, \trop(f_i)(\vec w)) \in
  \Delta_{\vec w}(f)$. We denote by $\Lambda(f)$ and $\Lambda_{\vec w}(f)$ the sets of
  negatives of all slopes of $\Delta(f)$ and $\Delta_{\vec w}(f)$ respectively.
  \label{def:newtonPoly}
\end{definition}

Note that these polygons are similar to the Newton \emph{polytopes} studied to compute
tropical hypersurfaces, but are not the same construction. The notion of unique Newton
polygons helps us to establish a link between valuations of roots and polynomials
evaluated at these roots:

\begin{proposition}
  \label{prp:expectedNewt}
  For a polynomial $f \in K[x_1, \dots, x_k]$ and a weight $\vec w \in \setR^{k-1}$ the
  following are equivalent:
  \begin{enumerate}
    \item $f$ has a unique Newton polygon at $\vec w$, and
    \item for all $z \in K^{k-1}$ with valuation $\nu(z) = (\nu(z_1), \dots, \nu(z_{k-1}))
      = (w_1, \dots, w_{k-1}) = \vec w$ we have $\Delta(f(z, x_k)) = \Delta_{\vec w}(f)$.
  \end{enumerate}
\end{proposition}

In other words, if $f$ has a unique Newton polygon we may regard its expected Newton
polygon instead of evaluating $f$ at a partial solution for a subset of variables and vice
versa. Now, the use of Newton polygons becomes apparent with the following lemma, which
draws the connection between valuations of roots and the slopes of the Newton polygons:

\begin{lemma}[{\cite[Proposition~II.6.3]{neuAlg}}]
  Let $f \in K[x]$ be a univariate polynomial and $e$ be an edge of the Newton polygon
  $\Delta(f)$ connecting vertices $(r,x)$ and $(s, y)$ with slope $-m = \frac{y-x}{s-r}$.
  Then $f$ has exactly $s-r$ roots with valuation $m$.
  \label{lem:newtPolyRoots}
\end{lemma}

Proposition~\ref{prp:expectedNewt} and Lemma~\ref{lem:newtPolyRoots} naturally lead to the
formulation of the following algorithm to compute tropical varieties of zero-dimensional
ideals given by a triangular set. By Proposition~\ref{prp:triang} this then enables us to
compute the tropical variety of any zero-dimensional ideal by applying the algorithm to
each set in the triangular decomposition:

\begin{algo}[Zero-dimensional tropical varieties,
  {\cite[Algorithm~2.10]{tropPointsLinks}}]\
  \begin{algorithmic}[1]
    \Require a triangular set $F = \{f_1, \dots, f_n\} \subseteq K[x_1, \dots, x_n]$ with
    zero-dimensional affine variety $V(F) \subseteq \setT^n$.
    \Ensure $\vec w \in \Trop(F)$.
    \State Pick $w_1 \in \Lambda(f_1)$.
    \label{alg:pick1}
    \For{$i = 2, \dots, n$}
      \If{$f_i$ has unique Newton polygon at $(w_1, \dots, w_{i-1})$}
        \State Pick $w_i \in \Lambda_{(w_1, \dots, w_{i-1})}(f_i)$.
        \label{alg:pick2}
      \Else
        \State Compute root $(c_1, \dots, c_{i-1}) \in V(f_1, \dots, f_{i-1})$
        \State Pick $w_i \in \Lambda(f_i(c_1, \dots, c_{i-1}, x_i))$.
        \label{alg:pick3}
      \EndIf
    \EndFor
    \State \textbf{return} $\vec w = (w_1, \dots, w_n)$;
  \end{algorithmic}
  \label{alg:zeroDimTrop}
\end{algo}

If, instead of picking a single slope in lines \ref{alg:pick1}, \ref{alg:pick2} and
\ref{alg:pick3}, we iterate over the entire respective sets of slopes, the algorithm will
compute the complete tropical variety $\Trop(F)$. The \enquote{else}-case in this
algorithm is required in the rare case that a polynomial does not admit a unique Newton
polygon. An example of how such a computation might look like is given as follows:

\begin{example} \label{ex:zeroDimTrop}\
  \begin{enumerate}
    \item This is an interesting and  non-trivial example given in
      \cite[Example~2.13]{tropPointsLinks}. Considering the triangular set $F = \{ f_1,
      f_2, f_3 \} \subseteq \CCt[x_1, x_2, x_3]$ given by
      \[
        f_1 = tx_1^2 + x_1 + 1, \quad
        f_2 = tx_1x_2^2 + x_1x_2 + 1, \quad
        f_3 = x_1x_2x_3+1,
      \]
      each step in the algorithm allows several choices of unique Newton polygons as
      illustrated in Figure~\ref{fig:seriesOfNewtonPolygons}. Iterating over all of them
      yields the tropical variety
      \[
        \Trop(F) = \{ (0,0,0), (0,-1,1), (-1,1,0),(-1,-1,2) \}.
      \]
    \item While the first example can be solved entirely using Newton polygons, there are
      still some triangular sets which do not admit a series of unique Newton polygons. In
      these cases we have to explicitly find points on the (very) affine variety of the
      corresponding ideal. In our applications we will usually work over the field of
      complex formal Puiseux series $\CCt$ where we may apply the method used to prove
      Theorem~\ref{thm:puisuexalgclosed} to successively obtain finite approximations to
      the generally infinite power series solutions. In particular, the intermediate
      results will usually be elements of $\setQ(t)$ or $\setQ(a)(t)$ for some algebraic
      extension $\setQ(a)$ of $\setQ$. Consider now the simple triangular set $F = \{ f_1,
      f_2, f_3 \} \subseteq \CCt[x,y,z]$ given by
      \[
        f_1 = tx^2 - x + 1, \quad
        f_2 = ty - 1, \quad
        f_3 = tz - tx + 1.
      \]
      Applying Algorithm~\ref{alg:zeroDimTrop} shows that not all polynomials admit a
      unique Newton polygon: It is easy to see that for $\vec w \in \Trop(F)$ we must have
      $w_1 \in \{ -1, 0 \}$ and $w_2 = -1$. $f_3$ has homogeneous decomposition $f_3 = (1
      - tx) + tz$, but the initial ideal $\initial_{(-1,-1)}(1-tx) = 1-tx$ is no monomial.
      Clearly, $f_2$ has the single root $y = t^{-1}$. For $f_1$, applying the iterative
      Newton-Puiseux method we obtain two expansions
      \begin{align*}
        1 + t + 2t^2 + 5t^3 + 14t^4 + 42 t^5 + \cdots \\
        t^{-1} - 1 - t - 2t^2 - 5t^3 - 14t^4 - 42t^5 + \cdots
      \end{align*}
      up to order 5. After some tedious substitutions we finally find that $\Trop(F) = \{
      (0,-1,-1), (-1,-1,0) \}$.
      \label{ex:zdt2}
  \end{enumerate}
\end{example}

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}
    % first level
    \fill[blue!20] (-1,2.5) -- (-1,0) -- (0,0) -- (1,1) -- (1,2.5) -- cycle;
    \draw (-1,2.5) -- (-1,0)
    (1,1) -- (1,2.5);
    \draw[thick,black]
      (-1,0) -- node[above,black,font=\scriptsize] {$0$} (0,0);
    \draw[thick,black]
      (0,0) -- node[anchor=south east,xshift=0.1cm,yshift=-0.1cm,black,font=\scriptsize] {$1$} (1,1);
    \fill (-1,0) circle (0.075cm);
    \fill (0,0) circle (0.075cm);
    \fill (1,1) circle (0.075cm);
    \node[font=\small] at (0,1.75) {$\Delta(f_1)$};

    \draw[->,black] (-1.25,-0.75) --
      node[left,black,font=\small] {$w_1=0$} ($(-1.25,-0.75)+(-0.75,-1.25)$);
    \draw[->,black] (1.25,-0.75) --
      node[right,black,font=\small] {$w_1=-1$} ($(1.25,-0.75)+(0.75,-1.25)$);

    % second level
    \node (o11) at (-3,-4) {};
    \fill[blue!20] ($(-1,1.5)+(o11)$) -- ($(-1,0)+(o11)$) -- ($(0,0)+(o11)$)
      -- ($(1,1)+(o11)$) -- ($(1,1.5)+(o11)$) -- cycle;
    \draw ($(-1,1.5)+(o11)$) -- ($(-1,0)+(o11)$)
      ($(1,1)+(o11)$) -- ($(1,1.5)+(o11)$);
    \draw[thick,black]
      ($(-1,0)+(o11)$) -- node[above,black,font=\scriptsize] {$0$} ($(0,0)+(o11)$);
    \draw[thick,black]
      ($(0,0)+(o11)$) -- node[above,black,font=\scriptsize] {$1$} ($(1,1)+(o11)$);
    \fill ($(-1,0)+(o11)$) circle (0.075cm);
    \fill ($(0,0)+(o11)$) circle (0.075cm);
    \fill ($(1,1)+(o11)$) circle (0.075cm);
    \node[font=\small] at ($(0,1.75)+(o11)$) {$\Delta_0(f_2)$};

    \draw[->,black] ($(-1.25,-0.75)+(o11)$) --
      node[left,black,font=\small] {$w_2=0$} ($(-1.25,-0.75)+(-0.25,-1.25)+(o11)$);
    \draw[->,black] ($(1.25,-0.75)+(o11)$) --
      node[right,black,font=\small] {$w_2=-1$} ($(1.25,-0.75)+(0.25,-1.25)+(o11)$);

    \node (o12) at (3,-4) {};
    \fill[blue!20] ($(-1,1.5)+(o12)$) -- ($(-1,0)+(o12)$) -- ($(0,-1) + (o12)$)
      -- ($(1,0)+(o12)$) -- ($(1,1.5)+(o12)$) -- cycle;
    \draw ($(-1,1.5)+(o12)$) -- ($(-1,0)+(o12)$)
      ($(1,0)+(o12)$) -- ($(1,1.5)+(o12)$);
    \draw[thick,black] ($(-1,0)+(o12)$) --
      node[above,black,font=\scriptsize,xshift=4pt] {$-1$} ($(0,-1)+(o12)$) --
      node[above,black,font=\scriptsize] {$1$} ($(1,0)+(o12)$);

    \fill ($(-1,0)+(o12)$) circle (0.075cm);
    \fill ($(0,-1)+(o12)$) circle (0.075cm);
    \fill ($(1,0)+(o12)$) circle (0.075cm);
    \node[font=\small] at ($(0,1.75)+(o12)$) {$\Delta_1(f_2)$};

    \draw[->,black] ($(-1,-1.25)+(o12)$) --
      node[right,black,font=\small] {$w_2= 1$} ($(-1.5,-0.75)+(0,-1.25)+(o12)$);
    \draw[->,black] ($(1,-1.25)+(o12)$) --
      node[right,black,font=\small] {$w_2= -1$} ($(1.5,-0.75)+(0,-1.25)+(o12)$);

    % third level
    \node (o21) at ($(o11)+(-2,-3.3)$) {};
    \fill[blue!20] ($(0,0.5)+(o21)$) -- ($(0,0)+(o21)$) -- ($(1,0)+(o21)$) -- ($(1,0.5)+(o21)$) -- cycle;
    \draw ($(0,0.5)+(o21)$) -- ($(0,0)+(o21)$)
      ($(1,0)+(o21)$) -- ($(1,0.5)+(o21)$);
    \draw[thick,black]
      ($(0,0)+(o21)$) -- node[above,black,font=\scriptsize] {$0$} ($(1,0)+(o21)$);
    \fill ($(0,0)+(o21)$) circle (0.075cm);
    \fill ($(1,0)+(o21)$) circle (0.075cm);
    \node[font=\small] at ($(0.5,0.8)+(o21)$) {$\Delta_{(0,0)}(f_3)$};

    \node (o22) at ($(o11)+(1,-3.3)$) {};
    \fill[blue!20] ($(0,0.5)+(o22)$) -- ($(0,0)+(o22)$) -- ($(1,-1)+(o22)$) -- ($(1,0.5)+(o22)$) -- cycle;
    \draw ($(0,0.5)+(o22)$) -- ($(0,0)+(o22)$)
      ($(1,-1)+(o22)$) -- ($(1,0.5)+(o22)$);
    \draw[thick,black]
      ($(0,0)+(o22)$) -- node[above,black,font=\scriptsize,xshift=0.1cm] {$-1$} ($(1,-1)+(o22)$);
    \fill ($(0,0)+(o22)$) circle (0.075cm);
    \fill ($(1,-1)+(o22)$) circle (0.075cm);
    \node[font=\small] at ($(0.5,0.8)+(o22)$) {$\Delta_{(0,-1)}(f_3)$};

    \node (o23) at ($(o12)+(-2,-3.3)$) {};
    \fill[blue!20] ($(0,0.5)+(o23)$) -- ($(0,0)+(o23)$) -- ($(1,0)+(o23)$) -- ($(1,0.5)+(o23)$) -- cycle;
    \draw ($(0,0.5)+(o23)$) -- ($(0,0)+(o23)$)
      ($(1,0)+(o23)$) -- ($(1,0.5)+(o23)$);
    \draw[thick,black]
      ($(0,0)+(o23)$) -- node[above,black,font=\scriptsize] {$0$} ($(1,0)+(o23)$);
    \fill ($(0,0)+(o23)$) circle (0.075cm);
    \fill ($(1,0)+(o23)$) circle (0.075cm);
    \node[font=\small] at ($(0.5,0.8)+(o23)$) {$\Delta_{(0,0)}(f_3)$};

    \node (o24) at ($(o12)+(1,-3.3)$) {};
    \fill[blue!20] ($(0,0.5)+(o24)$) -- ($(0,0)+(o24)$) -- ($(1,-2)+(o24)$) -- ($(1,0.5)+(o24)$) -- cycle;
    \draw ($(0,0.5)+(o24)$) -- ($(0,0)+(o24)$)
      ($(1,-2)+(o24)$) -- ($(1,0.5)+(o24)$);
    \draw[thick,black]
      ($(0,0)+(o24)$) -- node[above,black,xshift=0.2cm,font=\scriptsize] {$-2$} ($(1,-2)+(o24)$);
    \fill ($(0,0)+(o24)$) circle (0.075cm);
    \fill ($(1,-2)+(o24)$) circle (0.075cm);
    \node[font=\small] at ($(0.5,0.8)+(o24)$) {$\Delta_{(1,1)}(f_3)$};
  \end{tikzpicture}
  \caption{Series of Newton polygons of $F$ \cite[Figure~2]{tropPointsLinks}}
  \label{fig:seriesOfNewtonPolygons}
\end{figure}

With the ability to efficiently compute tropical varieties of zero-dimensional ideals, we
can now focus on the central elements of fan traversals: Computing non-trivial points on a
tropical variety to find a starting cone and computing tropical links to determine
neighboring cones.

Finding non-trivial points on the tropical variety is achieved by intersecting with
sufficiently generic hyperplanes until the variety is zero-dimensional, allowing us to
apply Algorithm~\ref{alg:zeroDimTrop}. But when is a point non-trivial? For an ideal $I
\idealof K[\vec x]$ we define the \emph{homogeneity space} of $I$ to be the
linear\footnote{if $I$ has constant coefficients} subspace
\[
  C_0(I) = \left\{ \vec w \in \setR^n : \initial_{\vec w}(I) = I \right\}.
\]
Note that this notation is not a coincidence: If $I$ has constant coefficients, then
$\initial_0(I) = I$, so $C_0(I) = \overline{C[0]}$. The homogeneity space can be computed
easily from any reduced Gröbner basis for $I$ and is trivially included in $\Trop(I)$ if
$I$ itself contains no monomial, that is, if $\Trop(I) \neq \varnothing$. In fact,
$C_0(I)$ is contained in every Gröbner cone which is itself contained in the tropical
variety, so computing a point in the homogeneity space offers no useful information for
our algorithms. Hence, we call a point $\vec w \in \Trop(I)$ \emph{non-trivial} if $\vec w
\not\in C_0(I)$. The following proposition formalizes the process of intersecting with
generic hyperplanes:

\begin{proposition}
  Let $I \idealof K[\vec x]$ be an ideal of dimension $\dim I = d$ with algebraically
  independent set $\{x_1, \dots, x_d\}$ and suppose its affine variety $X = V(I)$
  satisfies $X \cap \setT^n \neq \varnothing$. Then there exists an non-empty Zariski-open
  subset $U \subseteq \setT^d$ such that for all $\lambda \in U$
  \[
    \varnothing \neq X_\lambda =
    X \cap V(x_1-\lambda_1, \dots, x_d - \lambda_d) \subseteq \setT^n
  \]
  and $\dim X_\lambda = 0$.
  \label{prp:intersHyperp}
\end{proposition}

We further need independent sets of variables: A set $U \subseteq \{ x_1, \dots, x_n \}$
is called an \emph{independent set} of variables for an ideal $I \idealof K[x_1, \dots,
x_n]$ if $I \cap K[U] = \ideal0$. It is \emph{maximal} if $|U| = \dim I$. The resulting
algorithm then just uses that by Theorem~\ref{thm:tropComplexConn} the maximal cones in
the tropical variety have the same dimension as the defining ideal and puts
Proposition~\ref{prp:intersHyperp} to work:

\begin{algo}[Tropical Points, {\cite[Algorithm~3.3]{tropPointsLinks}}]\
  \begin{algorithmic}[1]
    \Require $I \idealof K[\vec x]$,
    \Ensure $\vec w \in \Trop(I) \setminus C_0(I)$.
    \State Compute a maximal algebraically independent set, say $\{x_1, \dots, x_d\}$ and
    the homogeneity space $C_0(I)$.
    \Repeat
      \State Pick $\vec w \in \setQ^d$ random with $\{\vec w\} \times \setR^{n-d} \cap
        C_0(I) = \varnothing$.
      \State Pick $c \in K^d$ random with $\nu(c) = \vec w$.
      \State Set $I_c := I|_{x_i = c_i} \idealof K[x_{d+1}, \dots, x_n]$
    \Until{$\dim(I_c) = 0$ and $V(I_c) \subseteq \setT^{n-d}$}
    \State Compute a triangular set $F$ with $I_c \subseteq \ideal F$.
    \State Compute $(w_{d+1}, \dots, w_n) \in \Trop(F)$ using
      Algorithm~\ref{alg:zeroDimTrop}.
    \State\textbf{return} $(w_1, \dots, w_d, w_{d+1}, \dots, w_n)$.
  \end{algorithmic}
  \label{alg:tropicalPoint}
\end{algo}

We previously did not specify how to compute an initial starting cone for
Algorithm~\ref{alg:traversal}. Computing the maximal Gröbner cone $C_{\vec w}(I)$ (resp.\
the corresponding pair of reduced Gröbner bases) containing the point $\vec w$ in its
relative interior will yield a suitable starting cone.

\begin{example}
  \label{ex:pointG25}
  We now apply this procedure to find a non-trivial point of the ideal
  \begin{align*}
    I = \bigl\langle
      & x_{3,4}x_{2,5}-x_{2,4}x_{3,5}+x_{2,3}x_{4,5},
        x_{3,4}x_{1,5}-x_{1,4}x_{3,5}+x_{1,3}x_{4,5}, \\
      & x_{2,4}x_{1,5}-x_{1,4}x_{2,5}+x_{1,2}x_{4,5},
        x_{2,3}x_{1,5}-x_{1,3}x_{2,5}+x_{1,2}x_{3,5}, \\
      & x_{2,3}x_{1,4}-x_{1,3}x_{2,4}+x_{1,2}x_{3,4}
    \bigr\rangle \idealof K[x_{1,2}, \dots, x_{4,5}]
  \end{align*}
  which describes the Grassmannian $\Grass(2,5)$ in the Plücker embedding, see
  Section~\ref{sec:grass}. This ideal is 7-dimensional and has maximal independent set
  $\{x_{1,2}, \dots, x_{2,5} \}$. In the first step we must intersect with suitable
  hyperplanes in $x_{1, 2}, \dots, x_{2,5}$. By intersecting with, for instance,
  $(c_{1,2}, \dots, c_{3,4}) = (2,4,6,8,7,5,3)$ and computing a Gröbner basis of $I_c
  \idealof K[x_{3,4},x_{3,5},x_{4,5}]$ we obtain the triangular set
  \[
    x_{3,4} + t^{11} - t^{7},\quad
    x_{3,5} + t^{13} - t^{5},\quad
    x_{4,5} + t^{11} - t^{7}
  \]
  and just by looking we see that $(7,5,7) \in \Trop(I_c)$, so $(2,4,6,8,7,5,3,7,5,7) \in
  \Trop(I)$ is a non-trivial point in $\Trop(I)$.
\end{example}

To conclude this section, we want to study an alternative method of obtaining points in
neighboring Gröbner cones. As introduced in our brief discussion of
Algorithm~\ref{alg:tropBasisCurve}, the key ingredient is the so-called tropical
curve, a special form of tropical variety:

\begin{definition}
  A tropical variety is called a \emph{tropical curve} if it is one-dimensional, that is,
  it is the support of a one-dimensional complex of Gröbner polyhedra. $\Trop(I)$ is
  called \emph{combinatorially a curve} if $\Trop(I)/C_0(I)$ is one-dimensional.
\end{definition}

The idea is that, by passing to a facet of a maximal Gröbner cone, we can give a local
description of all Gröbner cones that are adjacent to this facet. Indeed, by taking any
$\vec u \in \Trop(I)$ contained in a cell of codimension one, that is, a facet of a
maximal Gröbner cone of the corresponding polyhedral fan, we consider the \emph{tropical
link} $\Trop(\initial_{\vec u}(I))$ of $I$ around $\vec u$. This set is the support of a
polyhedral fan, since it is a tropical variety, and also combinatorially a curve which
describes $\Trop(I)$ locally around $\vec u$. This was shown in the proof of correctness
of \cite[Algorithm~4.10]{compTropVar}: Assume $\Trop(I)$ has dimension~$d$ and choose a
facet $F$ and $\vec u$ in the relative interior of $F$, then $\Trop(\initial_{\vec u}(I))$
will be $d$-dimensional as well, while $F$ is $d-1$-dimensional. By definition,
$\initial_{\vec u}(I)$ is homogeneous with respect to all weights in $F$, so
$C_0(\initial_{\vec u}(I))$ is $d-1$-dimensional. This just means that
$\Trop(\initial_{\vec u}(I))$ is combinatorially a curve. Furthermore, by
\cite[Proposition~1.13]{SturmGBCP} we have that
\[
  \initial_{\vec v}(\initial_{\vec u}(I)) = \initial_{\vec v + \epsilon \vec u}(I)
\]
for all $\vec v$ for some appropriate $\epsilon>0$. Hence $\Trop(\initial_{\vec u}(I))$
contains relative interior points of all maximal Gröbner cones that have $F$ as a facet,
yielding the claimed \enquote{local description}. To apply this result in an algorithm,
the following additional results are required:

\begin{theorem}[{\cite[Theorem~1.1]{ossTropLift}}]
  \label{thm:tropInt}
  Let $X$ and $X'$ be two affine subvarieties. If the intersection $\Trop(X) \cap
  \Trop(X')$ has codimension $\codim\Trop(X) + \codim\Trop(X')$ in a neighborhood of $\vec
  w$, then $\vec w \in \Trop(X\cap X')$.
\end{theorem}

\begin{corollary} \label{cor:tropInt}
  In the setting of \ref{thm:tropInt} we in particular obtain:
  \begin{enumerate}
    \item Assume $\Trop(I)$ is combinatorially a curve with $\dim C_0(I) = d$ and
      \[
        C_0(I)\cap \Lin(e_{d+1}, \dots, e_n) = \{0\},
      \]
      then for any $c \in \setT^d$ we have
      \[
        \Trop(I) \cap \{\nu(c)\} \times \setR^{n-d} = \Trop(I + \ideal{x_1-c_1, \dots,
        x_d-c_d}),
      \]
      and this tropical variety is a tropical curve.
      \label{cor:i}
    \item If $\Trop(I)$ is a one-dimensional polyhedral fan, then for any $c \in K^* =
      \setT^1$ with $\nu(c)\neq0$ we have
      \[
        \Trop(I) \cap \{\nu(c)\} \times \setR^{n-1} = \Trop(I + \ideal{x_1-c_1})
      \]
      and this tropical variety is zero-dimensional.
      \label{cor:ii}
  \end{enumerate}
\end{corollary}

Finally, the structure of the tropical combinatorial curves $\Trop(\initial_{\vec w}(I))$ together
with the above corollaries culminate in the following algorithm:

\begin{algo}[Tropical Links, {\cite[Algorithm~4.5]{tropPointsLinks}}]\
  \label{alg:tropLinks}
  \begin{algorithmic}[1]
    \Require $I \idealof K[\vec x]$ such that $\Trop(I)$ is combinatorially a curve and a
    polyhedral fan,
    \Ensure $W \subseteq \setR^n$ such that $\Trop(I) = \bigcup_{\vec w \in W} \vec w
      \cdot \setR_{\geq0} + C_0(I)$
    \State Suppose $\dim C_0(I) = d$ and assume w.l.o.g. $C_0(I) \cap \Lin(e_{d+1}, \dots,
      e_n) = \{0\}$.
    \State Let $J \idealof K[x_d, \dots, x_n]$ be the image of $I$ under the substitution
      map
      \[
        K[x_1, \dots, x_n] \to K[x_d, \dots, x_n], x_i \mapsto
        \begin{cases}
          t, & \text{if } i < d, \\
          x_i & \text{else},
        \end{cases}
      \]
      where $t \in K$ is $t = t^1 = \phi(1)$ as in Lemma~\ref{lem:valSplit}.
      \label{alg:links:cut}
    \For{$i = d, \dots, n$}
      \State Let $J_i^\pm$ be the images of $J$ under the maps $x_i \mapsto t^\pm$
        respectively,
        \label{alg:links:curve}
      \State Compute $V_i^\pm = \Trop(J_i^\pm)$ using Algorithm~\ref{alg:zeroDimTrop},
      \State Set
        \begin{align*}
          W_i^\pm := \Bigl\{
            &(1, \dots, 1, w_d, \dots, w_{i-1}, \pm1, w_{i+1}, \dots, w_n) : \\
            &(w_d, \dots, w_{i-1}, w_{i+1}, \dots, w_n) \in V_i^\pm
          \Bigr\} \subseteq \setR^n
        \end{align*}
      \State Scale elements of $W_i^\pm$ positively until they are primitive in $\setZ^n$.
    \EndFor
    \State Set $W = \bigcup_{i=d}^n (W_i^+ \cup W_i^-)$.
    \State\textbf{return} $W$.
  \end{algorithmic}
\end{algo}

Indeed, the steps above are just applying Corollary~\ref{cor:tropInt} for every remaining
dimension: In line~\ref{alg:links:cut} we cut the combinatorial curve down to an actual
tropical curve by Corollary~\ref{cor:tropInt}.\ref{cor:i}. Then, in
line~\ref{alg:links:curve} we consider the respective zero-dimensional varieties described
in \ref{cor:tropInt}.\ref{cor:ii}. Note that, since a tropical curve is the support of a
tropical fan in this setting, it is necessarily a collection of rays. Hence the
representation as $\bigcup_{\vec w \in W} \vec w\cdot \setR_{\geq0} + C_0(I)$ is
justified. This algorithm can then be used as a replacement for the methods concerning
prevarieties in line \ref{alg:interiorPoints} of Algorithm~\ref{alg:neighbors}. As the
timings in \cite{tropPointsLinks} show, this yields a considerable speedup in general.

\section{Parallelization}

In this section we want to discuss our main contribution for this thesis: the combination
of \textsc{Singular}-methods to compute tropical varieties with recently developed
parallelization efforts at Fraunhofer ITWM for computer algebra software. The first
efforts to this end are described in \cite{towardsParallel} while we specifically base our
work on parallelization algorithms by Christian Reinbold to compute GIT-fans
\cite{reinboldGitFan}. The basic algorithms described in the previous section are
implemented in the \textsc{Singular} library \texttt{tropicalNewton.lib}
\cite{tropNewtLib} and parallelization of our procedures is taken care of by the GPI-Space
environment \cite{gpispace}. The objective is to speed up computation of tropical
varieties by exploiting concurrency and running on as many machines as possible. To this
end, it it necessary to identify the components where this concurrency may be exploited,
as well as those components which are inherently sequential.

In the following, we will provide a brief overview of GPI-Space, our workflow management
system of choice. In particular, we will discuss Petri nets and their extensions, which
are used as the coordination language in GPI-Space. We will then begin to reformulate our
algorithm as a Petri net and finally look into some implementation details to illustrate
some of the choices made.

\subsection{Petri Nets and GPI-Space}

GPI-Space is a workflow management system developed at the Fraunhofer Institut für
Wirtschafts- und Technomathematik which was designed to allow execution of arbitrarily
large or complex workflows on large scale computing systems \cite{gpispace}. It consists
of three main components \cite[Section~4.1]{reinboldGitFan}:
\begin{enumerate}[label=\arabic*.]
  \item The distributed run-time engine (DRTS) which constructs and manages worker
    topologies based on the available computing resources and is responsible for resource
    management and job scheduling. Hardware changes during exchanges, caused by failing
    components or dynamic addition of hardware, are also supported.
  \item The workflow engine (WE) which tracks the state of the workflow and identifies
    activities that can be executed. It then collects input data and active transitions
    into jobs which are sent to the DTRS for scheduling.

    Note that the WE is a single-threaded process running on a single machine, so it is
    imperative to design the workflow in way which does not place too much work on the WE
    as it otherwise may become a major bottleneck to the algorithm.
  \item A virtual memory layer that allows different activities and external programs to
    communicate and share data.
\end{enumerate}

Petri nets are used as a coordination language in GPI-Space, which allow us to formulate
our algorithms without explicitly specifying any parallelization. Furthermore, they can be
expressed as bipartite directed graphs, allowing them to be designed in an intuitive and
accessible way. During execution they are interpreted by the workflow engine. In
GPI-Space, the Petri nets and the expression language we will introduce later on are
formulated in an XML-language.

\begin{definition}[Petri net]
  \label{def:petri}
  A \emph{Petri net} is a triple $N = (P, T, F)$ of two disjoint finite sets $P$ and $T$,
  called \emph{places} and \emph{transitions} respectively, and a subset $F \subseteq
  (P\times T) \cup (T \times P)$ called the \emph{flow relation} of the net.
\end{definition}

This definition establishes the static part of a Petri net which is used to describe the
overall structure of a program. To describe the dynamic execution of a Petri net we
introduce the notion of markings:

\begin{definition}[Marking]
  \label{def:marking}
  Given a Petri net $(P,T,F)$ a \emph{marking} $M$ of the net is defined as a function $M
  : P \to \setN$. If $M(p) = k$ for some $k \in \setN$ then we say that $p$ \emph{holds
  $k$ tokens under $M$}.
\end{definition}

As we will use Petri nets with markings to formulate program flows in parallel, it makes
sense to think of transitions as the elementary algorithms with tokens representing the
data which is passed from and to these algorithms. Thus we will call $p$ an \emph{input}
to $t$ if $(p,t) \in F$ and analogously an \emph{output} to $t$ if $(t,p) \in F$.

We can also describe a marking by its graph $M = \{ (p, M(g)) : p \in P, M(g) \neq 0 \}$
of non-zero images. Such a marking $M$ is used to define the \emph{state} a Petri net: $M$
\emph{enables} a transition $t \in T$ if all input places of $t$ hold tokens, meaning that
$(p,t) \in F$ implies $M(g)>0$. In this case we write $\smash{M
\overset{t}{\longrightarrow}}$. In a Petri net with marking $M$ a transition $t$ enabled
by $M$ may be \emph{fired} by consuming a token from each input place of $t$ and adding a
token to each output place. This leads to a new marking $M'$ given by
\[
  M'(p) = M(p) - |\{ (p,t) \} \cap F| + |\{ (t,p) \} \cap F|
\]
for all $p \in P$. If $M'$ is defined in this way by firing $t$, then we write $\smash{M
\overset{t}\longrightarrow M'}$ and say that $M'$ is \emph{directly reachable} from $M$ by
firing $t$. In general we say that a marking $M'$ is \emph{reachable} if there is a
\emph{firing sequence} $\smash{M \overset{t_1}\longrightarrow M_1
\overset{t_2}\longrightarrow \cdots \overset{t_{n-1}}\longrightarrow M'}$. It is important
to note that the firing of enabled places is a local process, that is, it does not block
other enabled transitions from firing as well. This is the most important property
allowing parallelisms.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance=1.4cm]
    \begin{scope}
      \node [place,tokens=2] (in)                {};
      \node [place,tokens=3] (in2) [above of=in] {};
      \node [transition]     (f)   [right of=in,yshift=0.7cm] {}
        edge [pre] (in)
        edge [pre] (in2);
      \node [place]          (out) [right of=f]  {} edge [pre] (f);
    \end{scope}

    \begin{scope}[xshift=7cm]
      \node [place]          (in')                {};
      \node [place,tokens=1] (in2') [above of=in'] {};
      \node [transition]     (f')   [right of=in',yshift=0.7cm] {}
        edge [pre] (in')
        edge [pre] (in2');
      \node [place,tokens=2] (out') [right of=f']  {} edge [pre] (f');
    \end{scope}

    \draw [->,thick] ([xshift=5mm]out -| out) -- ([xshift=-5mm]f' -| in')
      node[above=1mm,midway,text centered] {\footnotesize firing two times};
  \end{tikzpicture}
  \caption{Transition firing until it is disabled}
  \label{fig:firing}
\end{figure}

A very useful property of Petri nets is the fact that their static part given by
Definition~\ref{def:petri} can be visualized as a directed bipartite graph. Recall that a
directed graph $G = (V,E)$ is \emph{bipartite} is there is some partition $V = V_1 \dotcup
V_2$ of the node set such that $E \subseteq (V_1 \times V_2) \cup (V_2 \times V_1)$,
meaning no arc connects nodes lying in the same set $V_i$. But, by definition of the Petri
net $(P,T,F)$, this clearly holds for the graph $G = (P \cup T, F)$ where we interpret
places and transitions as nodes and their flow relations as arcs. This will be illustrated
in the upcoming examples, see for instance Figures~\ref{fig:firing} and \ref{fig:petriEx}.
Usually, places will be represented by circles and transitions as boxes, while tokens held
by places will be drawn as points in the corresponding place. We will also mark places or
transitions with letters if necessary.

\begin{figure}[htbp]
  \centering
  \begin{subfigure}{.35\textwidth}
    \centering
    \begin{tikzpicture}[node distance=1.4cm]
      \node [place]      (in)                {$i$};
      \node [transition] (f)   [right of=in] {$f$} edge [pre] (in);
      \node [place]      (out) [right of=f]  {$o$} edge [pre] (f);
    \end{tikzpicture}
    \caption{Data parallelism}
    \label{fig:petri:datapar}
  \end{subfigure}
  \begin{subfigure}{.64\textwidth}
    \centering
    \begin{tikzpicture}[node distance=1.4cm]
      \node [place]      (in) {};
      \node [transition] (s)  [right of=in] {$s$} edge [pre] (in);

      \node [place]      (su) [above right of=s] {}    edge [pre] (s);
      \node [transition] (f)  [right of=su]      {$f$} edge [pre] (su);
      \node [place]      (l)  [right of=f]       {}    edge [pre] (f);

      \node [place]      (sd) [below right of=s] {}    edge [pre] (s);
      \node [transition] (g)  [right of=sd]      {$g$} edge [pre] (sd);
      \node [place]      (r)  [right of=g]       {}    edge [pre] (g);

      \node [transition] (j)  [below right of=l] {}    edge [pre] (l) edge [pre] (r);
      \node [place]      (o)  [right of=j]       {}    edge [pre] (j);
    \end{tikzpicture}
    \caption{Task parallelism}
    \label{fig:petri:taskpar}
  \end{subfigure}
  \caption{Minimal Petri nets illustrating parallelisms}
  \label{fig:petriEx}
\end{figure}

\begin{example}[Parallelisms in Petri Nets, {\cite[Examples~3.4
  and~3.5]{towardsParallel}}] \label{ex:petriPar}
  We now want to look at how different kinds of parallelisms can be realized in Petri
  nets.
  \begin{enumerate}[label=(\alph*)]
    \item First, consider the Petri net $\Psi$ whose graph is depicted in
      Figure~\ref{fig:petri:datapar}. If $i$ holds multiple tokens, then $f$ is enabled
      and may fire for each on individually, in particular in parallel. If $f$ fires $n$
      times, we may extend the above notation to $\smash{M \overset{f^n}{\longrightarrow}
      M'}$ for corresponding markings $M, M'$. We may regard each token in $i$ as a part
      of a larger chunk of data that is fed to $f$. Note that we will introduce tokens
      which hold actual data later on. This parallel firing of a single transition for
      several chunks of data is referred to as \emph{data parallelism}.
    \item Consider now the Petri net given by the graph depicted in
      Figure~\ref{fig:petri:taskpar}. If $f$ and $g$ are enabled by firing $s$, then both
      $f$ and $g$ may thus fire in
      parallel. Constructions like this arise when different functions are applied to
      parts of some data and have no interdependence. Running different tasks like this in
      parallel is usually referred to as \emph{task parallelism}.
  \end{enumerate}
\end{example}

To summarize, Petri nets contain information about \emph{all} activities that may be
executed at any given time, making it possible to exploit the maximum amount of
parallelism. But as was hinted at above, Petri nets in the current form are not yet
suitable to model algorithms together with the data they produce as they arise from real
world applications. Another problem is the lack of conditional execution:

\begin{definition}[Conflicts]
  \label{def:conflict}
  Let $(P,T,F)$ be a Petri net with a marking $M$ such that some transitions $t_1$ and
  $t_2$ are enabled. Then $t_1$ and $t_2$ are in \emph{conflict} if firing $t_1$ disables
  $t_2$ or vice versa.
\end{definition}

More precisely, conflicts arise when a place does not hold enough tokens to fire all
transitions it enables, see for example Figure~\ref{fig:conflict}. This implies that the
execution of the Petri net is dependent on the choice of which transition to fire, which
in general is undesirable.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=1.4cm]
    \begin{scope}
      \node [place,tokens=2] (i01) {};
      \node [place,tokens=1] (i02) [below of=i01] {};
      \node [place,tokens=2] (i03) [below of=i02] {};

      \node [transition] (t01) [right of=i01,yshift=-0.7cm] {$t_1$}
        edge [pre] (i01)
        edge [pre] (i02);
      \node [transition] (t02) [below of=t01] {$t_2$}
        edge [pre] (i02)
        edge [pre] (i03);

      \node [place] (o01) [right of=t01] {} edge [pre] (t01);
      \node [place] (o02) [right of=t02] {} edge [pre] (t02);
    \end{scope}

    \begin{scope}[xshift=7cm,yshift=2cm]
      \node [place,tokens=1] (i11) {};
      \node [place] (i12) [below of=i11] {};
      \node [place,tokens=2] (i13) [below of=i12] {};

      \node [transition] (t11) [right of=i11,yshift=-0.7cm] {$t_1$}
        edge [pre] (i11)
        edge [pre] (i12);
      \node [transition] (t12) [below of=t11] {$t_2$}
        edge [pre] (i12)
        edge [pre] (i13);

      \node [place,tokens=1] (o11) [right of=t11] {} edge [pre] (t11);
      \node [place] (o12) [right of=t12] {} edge [pre] (t12);
    \end{scope}

    \begin{scope}[xshift=7cm,yshift=-2cm]
      \node [place,tokens=2] (i21) {};
      \node [place] (i22) [below of=i21] {};
      \node [place,tokens=1] (i23) [below of=i22] {};

      \node [transition] (t21) [right of=i21,yshift=-0.7cm] {$t_1$}
        edge [pre] (i21)
        edge [pre] (i22);
      \node [transition] (t22) [below of=t21] {$t_2$}
        edge [pre] (i22)
        edge [pre] (i23);

      \node [place] (o21) [right of=t21] {} edge [pre] (t21);
      \node [place,tokens=1] (o22) [right of=t22] {} edge [pre] (t22);
    \end{scope}

    \path ([xshift=5mm]i02 -| o01) edge [thick,post,out=0,in=180]
      node [pos=0.6,above=0.8cm] {firing $t_1$} ([xshift=-5mm]i12 -| i12);
    \path ([xshift=5mm]i02 -| o01) edge [thick,post,out=0,in=180]
      node [pos=0.6,below=0.8cm] {firing $t_2$} ([xshift=-5mm]i22 -| i22);
  \end{tikzpicture}
  \caption{Conflict of two transitions leading to different program flows}
  \label{fig:conflict}
\end{figure}

Ways to correct these issues include extending Petri nets to so-called \emph{colored} and
\emph{timed Petri nets}. While studying them in full detail is beyond the scope of this
thesis, we want to look at how they are realized in the GPI-Space environment, along with
the other important extensions (see \cite[Section~3.2.2]{towardsParallel} for more
details):

A traditional Petri net cannot model execution times of its transitions since the firing
process is in principle instantaneous. Clearly, this yields an incomplete description of
a realistic workflow. Timed Petri nets introduce the concept of time by extending the
firing process of transitions with an intermediate phase where consumed tokens are held in
the transition itself. Hence, markings as given by Definition~\ref{def:marking} have to be
extended by an intermediate marking corresponding to this intermediate phase. Note that
this does not change the execution dynamics of a Petri net in terms of reachability.

An even more important concept than time is data: Until now, all tokens in the classical
Petri net held no information apart from being present or not. Of course, this severely
limits the amount of information that can be exchanged between independent processes which
ultimately leads to the notion of colored Petri nets: We extend the Petri net $(P,T,F)$
with a finite set $\Sigma$ of \emph{token color sets} or \emph{types} together with a
\emph{color function} $C:P\to\Sigma$. In particular, all tokens in a given place have the
same coloring.

As above, a marking must be modified to not just count the amount of tokens in a given
place: A marking is now a map $\Gamma \to \setN$ where $\Gamma = \{ (p,c) : p \in P, c \in
C(p) \}$. So in some sense each place is associated with a certain collection of colors
and each such color can hold certain amounts of tokens. On the practical side, GPI-Space
enforces type safety of Petri nets just like in strongly typed programming language. This
is realized by equipping transition with \emph{ports} which are typed placeholders for
incoming and outgoing connections.

To add to the previous point, GPI-Space employs different types of ports. Depending on the
direction of an arc in a Petri net, a port will be either read from or written to, which
corresponds to consuming and placing a token respectively. In the cases where a token is
placed back in the place it was read form, we may also employ read-write ports.

Finally, there is the notion of a \emph{read-only} port. In cases where data is static
over the course of the Petri net execution and must be accessed by several different
transitions, for instance configuration data and static input, it would be overly tedious
to repeatedly consume and replace tokens. Furthermore, if this data sat in a single token
it would be inaccessible to any other transitions during execution, preventing parallel
access. The solution is to make this token read-only. Any transition which is enabled by
this token will then not consume it, so any others may access the corresponding data in
parallel.

GPI-Space provides an embedded programming language which serves a twofold purpose:
Firstly, it allows to define and utilize user-defined data types from a range of provided
standard types like integers, floating point numbers Booleans and lists thereof. These are
defined as \enquote{structs} in a similar fashion as in the C programming language. For
example in our later Petri nets we use \texttt{file} as an alias for \texttt{string},
accomplished by
\begin{verbatim}
<struct name="file">
  <field name="path" type="string" />
</struct>\end{verbatim}%
with a similar type \texttt{optional\_file} that includes a Boolean value indicating
whether the specified path is valid:
\begin{verbatim}
<struct name="optional_file">
  <field name="path" type="string" />
  <field name="valid" type="bool" />
</struct>\end{verbatim}%
This allows defining types recursively. For instance the input to our algorithm consists
of an ideal and an optional symmetry group, supplied as serialized files. This is
represented by the type
\begin{verbatim}
<struct name="problem_data">
  <field name="ideal" type="file" />
  <field name="symmetry_group" type="optional_file" />
</struct>\end{verbatim}%

Secondly, the expression language allows so-called \emph{tiny computations}. Suppose, for
instance, a token carries some sort of counter which is to be increased by some
transition. The expression language allows us to increment the counter without passing to
a dedicated process, but instead executing it directly in the workflow engine itself, for
instance by the snippet
\begin{verbatim}${counter} := ${counter} + 1\end{verbatim}
which could be used in the $+$-transition in Figure~\ref{fig:inc}. This way we may skip
the overhead of sending the data to the run-time system and returning it back to the
workflow engine. Clearly, this only makes sense for very basic computations, as otherwise
the workflow engine may become unavailable for its actual scheduling work during overly
expensive computations.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance=1.7cm]
    \node [place] (in) {$i$};
    \node [transition] (plus) [left of=in] {$+$}
      edge [pre, bend left] (in)
      edge [post,bend right] (in);
    \node [transition] (next) [right of=in] {} edge [pre] (in);
    \node at (plus) [above=0.4cm] {\footnotesize\verb|${i} :lt: 4|};
    \node at (next) [above=0.4cm] {\footnotesize\verb|${i} :ge: 4|};
  \end{tikzpicture}
  \caption{Incrementing net illustrating conditions}
  \label{fig:inc}
\end{figure}

We have already talked about conditional execution when we introduced conflicts: GPI-Space
extends the firing process of transitions with conditions depending on the properties of
the input tokens of a transition. Consider again the situation of a counter, incrementing
some variable. Figure~\ref{fig:inc} gives a rough sketch of how this might be implemented:
Here, $i$ is an integer value that is incremented as long as it is smaller than 4, and
afterwards passed on to some other transition.

Furthermore, conditional execution provides a tool to resolve potential conflicts as
described in Definition~\ref{def:conflict} and illustrated in Figure~\ref{fig:conflict}.
In fact, Petri nets formulated for GPI-Space require that any transitions may fire without
conflicts. This is again illustrated in Figure~\ref{fig:inc} as the two conditions shown
are mutually exclusive, that is, they can not both be true for a given token. GPI-Space
supports the common Boolean operators \texttt{:gt:} (greater than), \texttt{:ge:} (greater
than or equal), similarly \texttt{:lt:} and \texttt{:le:}, \texttt{:eq:} (equal) and so
on.

In Listing~\ref{lst:ez} we see a formulation for the Petri net depicted in
Figure~\ref{fig:petri:datapar} using the XML language utilized in GPI-Space. We assume
here that the transition $f$ is realized as a C-procedure that is implemented externally
and that the token hold some unspecified data of type \texttt{data}. Note that such a
Petri net has global input and output places which are then connected to their local
counterparts $i$ and $o$. These, in turn, are then connected to their corresponding ports
\texttt{input} and \texttt{output} in $t$.

\begin{lstlisting}[language=XML,basicstyle=\ttfamily\small,
  gobble=2,float,captionpos=b,frame=single,
  label=lst:ez,
  caption={GPI-Space implementation of Figure~\ref{fig:petri:datapar}}]
  <defun name="example_net">
    <in  name="input"  type="data" place="i" />
    <out name="output" type="data" place="o" />
    <net>
      <place name="i" type="data" />
      <place name="o" type="data" />
      <transition name="f" />
        <defun>
          <in  name="input"  type="data" />
          <out name="output" type="data" />
          <module name="example" function="output f(input)">
            <code><![CDATA[
              data output = function_which_computes_f(input);
              return output;
            ]]></code>
          </module>
        </defun>
        <connect-in  port="input"  place="i" />
        <connect-out port="output" place="o" />
      </transition>
    </net>
  </defun>
\end{lstlisting}

\subsection{Traversing a Fan in Parallel}
\label{sec:traverseParal}

Computing tropical varieties in our setting follows the general structure of a fan
traversal: Interpreting the maximal cones of a polyhedral fan together with their
adjacency relations as a connected graph, we may realize the fan traversal as a simple
graph traversal \cite{JenTravSym}. To this end, we want to formulate a version of
Algorithm~\ref{alg:traversal} enhanced with Algorithm~\ref{alg:tropLinks} into a Petri
net. Indeed, on first glance an implementation looks quite simple: After determining a
starting cone using Algorithm~\ref{alg:tropicalPoint} we construct a set of
\emph{unprocessed} and \emph{processed} cones respectively. However, these steps alone do
not suffice quite yet: Recall that transitions do not in general fire instantaneously, so
there might be situations where the set of unprocessed cones is empty, while some
transitions still process data. It is thus important to devise proper termination
conditions to stop the execution of the net. Before we can tackle this problem however, we
must first consider some implementation details which will be reflected in the
description of our algorithm.
\begin{enumerate}[label=\arabic*.]
  \item We must decide how to store and represent data and intermediate results. As we
    have already seen, a Gröbner cone can be represented by a pair reduced Gröbner bases,
    see Lemma~\ref{lem:grConEq}. In our applications, we usually add the actual Gröbner
    cone to obtain a data triple. As a requirement by \textsc{Singular}, an ideal is
    always given together with its ambient polynomial ring, which, in this case, contains
    both pairs. Hence, in practice, the data will consist of a polynomial ring together
    with two ideals and a polyhedral cone. As it turns out, the built-in storage solutions
    in the GPI-Space environment are not suitable to handle the amount of data that is
    exchanged between processes. Instead we use a separate storage solution that will be
    accessed by the GPI-Space environment. We will discuss implementation details hereof
    in the next section.
  \item We previously noted that it is necessary to be able to test two given Gröbner
    cones for equality. While we may compare the given initial ideals as they are uniquely
    determined by the Gröbner cone by definition, it is faster to instead consider the
    actual cones. If they are given in canonical form, we may associate a \emph{unique
    point} to each of them. It is then sufficient to compare the unique points with each
    other. The unique point may then also be used as a \emph{key} for storage purposes.

    Assume for the given cone $C$ that $C = \{ \vec x : A\vec x \leq 0 \}$, then its
    \emph{lineality space} is the linear subspace $L = \{ \vec x : A\vec x=0 \}$. To
    obtain a unique point which is stable under symmetry we first compute unique minimal
    set of primitive vectors which span $C$ in the orthogonal complement of $L$ and then
    take their sum. Obtaining these vectors is again possible via the double description
    method \cite{fuDD} and it is clear that, since spanning vectors are mapped to
    spanning vectors under symmetry, this yields a suitable interior point.
  \item Finally, in the context of tropical varieties it is desirable to consider the
    corresponding polyhedral fan modulo symmetry. More precisely, for a polyhedral fan
    $\mathcal F$ in $\setR^n$ we want to find a subgroup of permutations $G \leq S_n$ that
    acts trivially on $\mathcal F$ but produces non-trivial cone orbits, see for example
    \cite{JenTravSym} for more on this. It turns out that considering the cones modulo
    symmetry is compatible with how their unique points are computed, so we additionally
    get orbits of unique points. As these are just integer vectors, we may even pick a
    minimal representative by sorting lexicographically. This allows us to compare cones
    up to symmetry very efficiently.
\end{enumerate}
We now successively describe a Petri net modelling our traversal algorithm. However,
Algorithm~\ref{alg:traversal} is not yet formulated in a way that is suitable for
parallelization. We give a slight reformulation and add the computation of a starting pair
of Gröbner bases which serves as the input to Algorithm~\ref{alg:traversal}:

\begin{algo}[Traversal (Modified)]\
  \label{alg:traversalMod}
  \begin{algorithmic}[1]
    \Require A (homogeneous) prime ideal $I \idealof K[\vec x]$ and a symmetry group $G$
      as above.
    \Ensure The set of maximal Gröbner cones of the polyhedral fan whose support is
      $\Trop(I)$ (resp.\ the corresponding pairs of Gröbner bases).
    \State Compute a $\vec w \in \Trop(I) \setminus C_0(I)$ using
      Algorithm~\ref{alg:tropicalPoint}.
    \State Compute the pair $c_0 := (\mathcal G_{\prec_{\vec w}}(\initial_{\vec w}(I)),
      \mathcal G_{\prec_{\vec w}}(I))$ from $I$ and $\vec w$.
    \State Set $U = \{ c_0 \}$ and $P = \varnothing$.
    \While{$U \neq \varnothing$}
      \State Pick a pair of Gröbner bases $c \in U$.
      \If{$c \not\in P$} \label{alg:line:coneExists}
        \State Compute $N = \mathrm{Neighbors}(c)$ using Algorithm~\ref{alg:neighbors}
          enhanced by Algorithm~\ref{alg:tropLinks}.
        \State Set $U = U \setminus \{ c \} \cup N$, $P = P \cup \{ c \}$.
      \EndIf
    \EndWhile
    \State\textbf{return} $P$.
  \end{algorithmic}
\end{algo}

Note that in the implementation we check in line~\ref{alg:line:coneExists} for existence
with respect to the symmetry group $G$, so if $\{ \id \} \lneq G$ it is possible that we
discard cones which were not found yet themselves, but lie in the orbit of some cone in
$P$. This will become important later on again when we further refine this algorithm.

\begin{figure}[tbhp]
  \centering
  \begin{tikzpicture}[node distance=1.4cm]
    \node [place] (in) {$I$};
    \node [transition] (init) [right of=in] {$iC$} edge [pre] (in);

    \node [place] (unpList) [right of=init] {$uS$} edge [pre] (init);
    \node [transition] (split) [below of=unpList] {$sS$}
      edge [pre, bend left]   (unpList)
      edge [post, bend right] (unpList);
    \node [place] (cone) [right of=split] {$c$}
      edge [pre] (split);
    \node [transition] (neigh) [right of=unpList] {$n$}
      edge [pre] (cone)
      edge [post] (unpList);
    \node [transition] (e) [above of=unpList] {$e$} edge [pre] (unpList);
  \end{tikzpicture}
  \caption{Naive approach to traversing a polyhedral fan}
  \label{fig:naive}
\end{figure}

In Figure~\ref{fig:naive} we see a first sketch of what a possible formulation could look
like but note that no termination logic has been included yet. The net is executed as
follows:
\begin{itemize}
  \item It is initialized with a single token on the place $I$ which holds the pair $(I,
    G)$ for the prime ideal $I$ and its symmetry group $G$.
  \item The transition $iC$ consumes this token and computes an initial starting cone
    given as a triple
    \[
      c_{\vec w} = (
        \mathcal G_{\prec_{\vec w}}(\initial_{\vec w}(I)),
        \mathcal G_{\prec_{\vec w}}(I),
        C_{\vec w}(I)
      )
    \]
    of reduced Gröbner bases and their corresponding Gröbner cone. Afterwards, $iC$
    produces a token holding the datum $\{c_{\vec w}\}$.
  \item The place $uS$ holds tokens with \emph{sets} (or lists) of these triples as their
    data, which we interpret as the \emph{unprocessed} cones. For a token in $uS$ there is
    two cases for the set $\mathcal C$ it holds: It is the empty set or it contains a
    non-zero amount of Gröbner cone triples:
    \begin{itemize}
      \item If the token holds the empty set, then it will be consumed by the transition
        $e$ which does nothing else.
      \item Otherwise we may pick a $c_{\vec w} \in \mathcal C$. The transition $sS$
        consumes the token holding $\mathcal C$, pushes back $\mathcal C\setminus \{
        c_{\vec w}\}$ to $uS$ and pushes $c_{\vec w}$ to the place $c$.
    \end{itemize}
    In short, the transition $sS$ consumes tokens representing sets of triples and outputs
    tokens representing single triples.
  \item Finally, the transition $n$ consumes tokens from $c$ which hold triples as above
    and applies the modified neighbor algorithm to them. Accordingly, it produces sets of
    such triples which are then pushed to $uS$.
\end{itemize}
Note that for this to make sense we have to assume that the transition $n$ stores and has
access to the processed Gröbner cones and thus only pushes \enquote{new} cones onto the
place $uS$. As said above, this net does not contain any termination logic and is thus not
complete. One way to properly terminate if, and only if, no more neighbors can be found is
to keep track of the number of all tokens that hold unprocessed cones, including those
that are being processed. If this number drops to zero while all the places $sS$ and $c$
hold no tokens then the algorithm can terminate.

\begin{figure}[tbhp]
  \centering
  \begin{tikzpicture}[node distance=1.4cm]
    \node [place,tokens=1] (ctrl) {};
    \node [transition] (init) [right of=ctrl] {$iC$} edge [pre] (ctrl);

    \node [place] (unproc) [right of=init] {$u$} edge [pre] (init);
    \node [transition] (insert) [right of=unproc] {$i$} edge [pre] (unproc);
    \node [transition] (neighbors) [above of=unproc] {$n$} edge [post] (unproc);
    \node [place] (unprocCones) [above of=neighbors] {$c$} edge [post] (neighbors);
    \node [transition] (get) [right of=unprocCones] {$g$} edge [post] (unprocCones);

    \begin{scope}[color=blue]
      \node [place] (enabled) [below of=get] {$e$}
        edge [post,bend right] (get)
        edge [pre,bend left] (get)
        edge [post,bend right] (insert)
        edge [pre,bend left] (insert);
      \node at (get) [above=3mm] {\footnotesize\verb|${e}|};
    \end{scope}

    \node [database] (stor) [right of=enabled,xshift=1cm] {storage}
      edge [in=0,out=90,dotted,post,thick] (get)
      edge [in=0,out=-90,dotted,pre,thick] (insert);

    \node [place] (data) [above of=init] {$d$}
      edge [post,dashed] (init)
      edge [post,dashed] (neighbors);
  \end{tikzpicture}
  \caption{Traversal incorporating external storage, \cite[Figure~8]{reinboldGitFan}}
  \label{fig:naive:storage}
\end{figure}

Note that the algorithm given above is just a general graph traversal algorithm where $iC$
provides the starting node and $n$ provides neighboring nodes. Before we want to exploit
some properties specific to tropical varieties we have to incorporate the above storage
plans into our Petri net. This new version is depicted in Figure~\ref{fig:naive:storage}
and is basically what Christian Reinbold describes in Stage~3 of
\cite[Section~4.4]{reinboldGitFan} to traverse the GIT-fan.
\begin{itemize}
  \item The transitions $iC$ and $n$ are basically unchanged, take the same input and
    produce the same output as before, with one exception:
  \item The place $d$ holds the data $(I, G)$ and is read-only for our input ideal $I$ and
    the optional symmetry group $G$. If $G$ is not supplied we set $G=\{\id\}$. Hence $iC$
    fires by consuming the control token that was added. By initializing this place with
    exactly one token, we ensure that the initial Gröbner cone is computed exactly once.
    In the previous Petri net we implicitly assumed that $G$ is part of the tokens that
    are fed to $n$.
  \item Similarly, $u$ holds sets of unprocessed Gröbner cone and basis triples produced
    by $iC$ and $n$.
  \item The transitions $i$ and $g$ insert and get tokens of Gröbner cone sets
    respectively. For this they call retrieval and insertion operations provided by the
    external storage interface. Note that, as we may insert sets, this removes the need
    for the splitting operations by $sS$ in the previous net.
  \item Finally, $g$ and $i$ are \enquote{managed} by the place $e$ which holds a Boolean
    token indicating whether there are unprocessed cones available. This is realized as
    follows (see parts colored in blue in Figure~\ref{fig:naive:storage}):
    \begin{itemize}
      \item At the beginning of executing the net, \texttt{false} is placed in $e$ as no
        cones are available yet.
      \item If firing $i$ succeeds, that is, not all of the cones it inserted were already
        known, the token in $e$ is consumed and replaced by \texttt{true}.
      \item $g$ may only fire if $e$ holds \texttt{true}. If, upon firing $g$, no
        unprocessed cones can be retrieved from storage, we replace the token in $e$ with
        \texttt{false}.
    \end{itemize}
\end{itemize}

This now a general algorithm which can be applied to any polyhedral fan which connected in
codimension one, provided one has procedures of neighboring cones and a starting cone. As
an additional optimization we want to exploit a property of our method of traversing this
fan, which comes at a potential cost of generality of our algorithm. To this end, we
recall Algorithm~\ref{alg:neighbors} and note that we actually traverse the finer
bipartite graph consisting of maximal cones and their facets. The idea is to split up this
Neighbor algorithm into separate parts, passing from maximal cones to facets and from
facets to maximal cones respectively. This offers two advantages in comparison to the
general method:
\begin{itemize}
  \item Splitting the algorithm allows for a more fine-grained control over the job-sizes
    submitted to the run-time system.

    Note that we must be careful in choosing job-sizes: As the workflow engine is a
    single-threaded process it might become a major bottleneck to the algorithm if the
    number of jobs it is tasked with scheduling becomes to big.
  \item More importantly, in addition to storing all computed Gröbner cones with respect
    to symmetry, we want store all facets, which have been visited during the fan
    traversal. It is obvious that this is possible since the facets themselves are also
    polyhedral cones and thus have a unique interior point with which they may be
    identified. This will then reduce the amount of duplicate cone computations:

    Say, during computation we obtain the cone $C_2$ as a neighbor of $C_1$ by traversing
    the facet $F$ of both $C_1$ and $C_2$. If $C_2$ was not previously known,
    Algorithm~\ref{alg:neighbors} will be applied to $C_2$ as well at a later step in the
    traversal. During this run, we will traverse the facet $F$ another time, leading to
    superfluous computations as all of the maximal Gröbner cones adjacent to $F$ were
    already computed in the first traversal of $F$.
\end{itemize}
Note that the splitting of Algorithm~\ref{alg:neighbors} has to happen at the GPI-Space
level due to the second point, since the $\textsc{Singular}$-invocations only compute
\enquote{locally} and have no way of sharing the obtained facets other than communicating
via GPI-Space.

\begin{figure}[tbhp]
  \centering
  \begin{tikzpicture}[node distance=1.4cm]
    \node [place,tokens=1] (ctrl) {};
    \node [transition] (init) [right of=ctrl] {$iC$} edge [pre] (ctrl);
    \node [place] (uC) [right of=init] {$u$} edge [pre] (init);
    \node [transition] (insC) [right of=uC] {$i_1$} edge [pre] (uC);

    \node [place,color=blue] (eC) [right of=insC] {$e_1$}
      edge [bend right,pre,color=blue] (insC)
      edge [bend left,post,color=blue] (insC);
    \node [transition] (getC) [right of=eC] {$g_1$}
      edge [bend right,pre,color=blue] (eC)
      edge [bend left,post,color=blue] (eC);

    \node [place] (cone) [right of=getC] {} edge [pre] (getC);
    \node [transition] (facets) [above of=cone] {$f$} edge [pre] (cone);
    \node [place] (f) [above of=facets] {} edge [pre] (facets);
    \node [transition] (insF) [left of=f] {$i_2$} edge [pre] (f);

    \node [place,color=blue] (eF) [left of=insF] {$e_2$}
      edge [bend right,pre,color=blue] (insF)
      edge [bend left,post,color=blue] (insF);
    \node [transition] (getF) [left of=eF] {$g_2$}
      edge [bend right,pre,color=blue] (eF)
      edge [bend left,post,color=blue] (eF);

    \node [place] (ufac) [left of=getF] {} edge [pre] (getF);
    \node [transition] (neigh) [below of=ufac] {$n$}
      edge [pre] (ufac)
      edge [post] (uC);

    % storage
    \node [database] (cs) [below of=eC] {cones}
      edge [out=0,in=-90,dotted,post,thick] (getC)
      edge [out=180,in=-90,dotted,pre,thick] (insC);

    \node [database] (fs) [above of=eF] {facets}
      edge [out=180,in=90,dotted,post,thick] (getF)
      edge [out=0,in=90,dotted,pre,thick] (insF);

    % data
    \node [place] (data) [above of=eC] {$d$}
      edge [post,dashed] (neigh)
      edge [post,dashed] (facets)
      edge [out=-90,in=90,color=white,line width=4pt] (init)
      edge [post,dashed,out=-90,in=90] (init);

    % wew
    \node at (getC) [above=3mm,blue] {\footnotesize\verb|${|$\mathtt{e_1}$\verb|}|};
    \node at (getF) [below=3mm,blue] {\footnotesize\verb|${|$\mathtt{e_2}$\verb|}|};
  \end{tikzpicture}
  \caption{Refinement by splitting Neighbor procedure}
  \label{fig:refined}
\end{figure}

Figure~\ref{fig:refined} illustrates the necessary modifications to the Petri net from
Figure~\ref{fig:naive:storage}, which basically amount to including a second storage. The
net executes as follows:
\begin{itemize}
  \item Initialization and initial cone computation are unchanged.
  \item The places resp.\ transitions $i_k, e_k, g_k$ for $k \in \{1, 2\}$ work
    analogously to $i,e,g$ in the previous net. For $k=1$ we manage maximal Gröbner cones
    represented by their meta data, for $k=2$ we manage interior facet points together
    with their minimal representative with respect to $G$.
  \item The transition $f$ simply takes a Gröbner cone and computes its facets. It returns
    the interior points of these facets (considered with and without symmetry) together
    with meta data pointing to the \enquote{originating} cone.
  \item The transition $n$ now takes an interior facet point and the pair of reduced
    Gröbner bases (resp.\ their location on disk) included in the token and applies
    lines~\ref{alg:neigh:line:start}--\ref{alg:neigh:line:end} of
    Algorithm~\ref{alg:neighbors} to obtain the adjacent maximal Gröbner cones.
  \item The net terminates if all tokens corresponding to maximal cones and facets have
    been processed, which can be checked by the (implied) token counting mentioned before.
    Additionally, it is necessary that $e_1$ and $e_2$ hold \texttt{false}.
\end{itemize}

\subsection{Adaptation and Implementation Details}

As was previously mentioned we heavily rely on work done by Christian Reinbold on GIT-fans
\cite{reinboldGitFan}, realizing algorithms from \cite{compGitFan} in parallel. His work,
in turn, relies on work done by Lukas Ristau to seamlessly integrate \textsc{Singular}
into a GPI-Space project, particularly for \cite{towardsParallel}. Since the foundation
for our application was laid by Reinbold, it is best to check for details in
\cite[Section~4]{reinboldGitFan}. As described in this thesis, the computation of the
GIT-fan is a 3-stage algorithm of which only the third stage is involves traversing a fan.
Hence, for our applications we had to remove the unnecessary stages from the workflow and
modify the existing traversal Petri net to our needs. We will give a short overview of
implementation details that are especially important for our implementation.

One of the bigger challenges of parallelizing algorithms for algebraic geometry is
integrating the computer algebra system \textsc{Singular} into the GPI-Space environment.
\textsc{Singular} provides a C/\Cpp-interface which can be accessed easily from within
GPI-Space, but we still have to deal with some nuisances
\cite[Section~4.2]{reinboldGitFan}. Particularly relevant to our implementation are:
\begin{itemize}
  \item Most functionality of \textsc{Singular} is available through libraries written in
    its interpreter language. This language only provides array-like lists for storing
    collections of data. This is unsuitable for larger data sets like the collection of
    cones we must manage during the computation of a tropical variety. We thus externalize
    this to the GPI-Space-level where we may use structures provided by the Standard
    Template Library (STL) of \Cpp.
  \item First tests have shown that using the built-in virtual memory layer of GPI-Space
    is not suitable for passing Gröbner cone data between processes as growing file sizes
    will overwhelm the management engine. In addition to this, \textsc{Singular} does not
    provide serialization of data into memory. It is thus unavoidable to write our cone
    data to disk. Of course, this requires that all compute nodes used have access to a
    shared (network) storage. On the computing cluster provided by Fraunhofer ITWM this is
    achieved via the file system \textsc{BeeGFS} \cite{bgfs}, which allows efficient
    parallel access to storage.
\end{itemize}

Now, as Gröbner cones must be stored on disk, we must decide how to identify and represent
the data. As \textsc{Singular} provides the \emph{simple singular interface} (SSI) to
serialize its data into files, it suffices to devise a method to determine unique file
names for our data. Making file names dependent on the Gröbner cones contained therein
might yield race conditions or corrupted data, as different processes might compute the
same cone independently, thus writing into the same file at the same time. Another problem
that might arise from this is the limited file path length of most file systems, since the
size of identifying information grows with problem size as well.

Hence we chose to assign each Neighbor-computation a unique ID, provided by a counter.
This is then added as a simple self-incrementing counter to the Petri net given in
Figure~\ref{fig:refined}, supplying transition $n$ with IDs. Note that the only
information we obtain in transition $f$ is the interior point of a facet which can be
stored in a token. Each neighbor computation then creates a directory named after its ID
and writes the resulting Gröbner cone data into numbered SSI-files \texttt{0.ssi},
\texttt{1.ssi} and so on. The token corresponding to this Gröbner cone in the Petri net
then contains the interior point of the cone as a unique identifier the relative file path
\texttt{ID/n.ssi} to keep track of the data.

To conclude, we want to revisit the token counting used to properly terminate our nets
which was mentioned multiple times. In the final iteration of our net depicted in
Figure~\ref{fig:refined} this is particularly easy: The transition $n$ consumes a single
token and creates a single token for each invocation, so it does not change the total
number of tokens by itself. The same is true for $f$, so the only transitions which change
the number of tokens representing cones or facets are $iC$ and $i_k, g_k$ for $k=1,2$.
These changes can be kept track of by adding a counter which is incremented for each
firing of $iC$, $g_1$ and $g_2$ and decremented for each firing of $i_1$ and $i_2$. If
this counter drops to zero while both $e_1$ and $e_2$ hold the \texttt{false}-token we
terminate the net.

In Figure~\ref{fig:full_net} we included a rendition of our Petri net as it is realized in
practice to illustrate the complexity of the final product. We see\footnote{by using a
magnifying glass} that the additional places and transitions described above severely
impact the structure of the net and make it rather confusing. It further includes a final
transition that combines all found cones from their files on disk into a single file.

\begin{figure}[htbp]
  \includegraphics[width=\textwidth]{fig/traversal_net.pdf}
  \caption{Net from Figure~\ref{fig:refined} with all additions, rendered with GPI-Space
  utilities}
  \label{fig:full_net}
\end{figure}

\section{Performance and Scalability}

In this section we want to apply our implemented algorithms to examples originating from
current research in order to examine how efficiently they parallelize. The idea is to
consider examples which are \enquote{big} enough to provide reliable parallelization
timings. An important class of (tropical) varieties already considered in
\cite{tropPointsLinks} and \cite{tropGrass} are the so-called \emph{tropical
Grassmannians}. We want to compare the single-threaded computing times of the
\textsc{Singular}-only version of our algorithm with the parallel version by considering
the tropical Grassmannian $\mathcal G_{3,7}$. While this tropical variety is sufficiently
small to be computed successfully on any individual machine, we also want to consider
examples which have not been computed in their entirety before. An example for this is the
much larger tropical Grassmannian $\mathcal G_{3,8}$.

Our running time tests were executed on the computing cluster provided by Fraunhofer ITWM
in Kaiserslautern. This cluster is comprised of 192 computing nodes each fitted with 16
Intel Xeon E5-2670 processor cores running at 2.6\,GHz with 64\,GB memory. The GPI-Space
engine uses these cores without hyperthreading, meaning we may run a maximum of 16 jobs
per node. The nodes are connected via FDR Infiniband.

\subsection{Tropical Grassmannians}
\label{sec:grass}

One important class of tropical varieties are the tropical Grassmannians which arise as
the tropical varieties of the equally -- if not more -- important classical Grassmannians
which are in fact projective varieties. Some results on the tropical Grassmannian can be
found in \cite{tropGrass}. The following is an overview of the construction of projective
Grassmannians found in \cite[Section~8]{gathmAlgGeo}.

\begin{definition}[Grassmannians]
  Let $n \in \setN_{>0}$ and $k \in \setN$ with $0 \leq k \leq n$, then the
  \emph{Grassmannian} of $k$-planes in $K^n$ is the set of all $k$-dimensional linear
  subspaces of $K^n$, usually denoted by $\Grass(k, n)$.
\end{definition}

Thus, Grassmannians are in some sense a generalization of projective space: for instance,
we will later be able to see that in fact $\Grass(1,n) \cong \setP^n$. Our goal now is to
give these sets the structure of a projective variety which in turn allows us to study
their tropical variety. This is achieved by embedding a Grassmannian $\Grass(k, n)$ into
$\setP^{\binom nk}-1$ via the so-called \emph{Plücker embedding}. To this end, we want to
regard the corresponding linear spaces as elements of projective space, which first
requires some constructions from commutative algebra.

Let $V$ and $W$ be two vector spaces and $k\in\setN$, then a multilinear map $f : V^k \to
W$ is called \emph{alternating} if for all $v_1, \dots, v_k$ with $v_i=v_j$ for some
distinct $i,j$ we have that $f(v_1, \dots, v_k) = 0$. In this setting an \emph{alternating
$k$-fold tensor product} of $V$ is a vector space $T$ together with an alternating map
$\wedge:V^k\to T, (v_1, \dots, v_k) \mapsto v_1\wedge\cdots\wedge v_k$ such that for any
other alternating map $f:W\to T$ there is a unique $\tilde f:T\to W$ satisfying $\tilde f
\circ \wedge = f$. It is easy to prove that such an alternating tensor product always
exists and is in fact unique up to isomorphism -- the proof is completely analogous to the
case of standard tensor products. Hence we may write $\bigwedge^k V = T$ for these vector
spaces. In the following we present some interesting and necessary properties of these
spaces which can be proved with basic knowledge of commutative algebra:

\begin{remark}
  Let $V$ be a vector space, $k \in \setN$ and $\bigwedge^k V$ the corresponding
  alternating tensor product.
  \begin{enumerate}
    \item If $v_1, \dots, v_n$ is a basis of $V$ where $n=\dim V$ as a $K$-vector space,
      then the set
      \[
        \left\{
          v_{i_1} \wedge \cdots \wedge v_{i_k} : 1\leq i_1 < \cdots < i_k \leq n
        \right\}
      \]
      will be a basis of $\bigwedge^kV$. In particular this vector has dimension
      $\dim\bigwedge^kV = \binom nk$.
    \item For elements $v_1, \dots, v_k \in V$ the \emph{pure tensor} $v_1\wedge \cdots
      \wedge v_k \in \bigwedge^kV$ will be non-zero if, and only if, $v_1, \dots, v_k$ are
      linearly independent in $V$.
    \item It follows that for two linear independent families $v_1, \dots, v_k, w_1,
      \dots, w_k \in V$ we have that $v\wedge\cdots \wedge v_k$ and $w_1\wedge\cdots\wedge
      w_k$ are linearly dependent if, and only if, the families both span the same linear
      subspace of $V$.
  \end{enumerate}
\end{remark}

Consider now our setting where $V=K^n$ and let $N = \smash{\binom nk}$ be the number of
basis elements in $\bigwedge^kK^n$. We may identify a $k$-dimensional linear subspace $X
\in \Grass(k,n)$ of $V$ with a pure tensor in $\bigwedge^kV \cong K^N$ uniquely up to
scalar multiplication which -- by definition -- makes the corresponding embedding
$\Grass(k,n) \to \setP^{N-1}$, called the \emph{Plücker embedding}, injective. Hence we
can regard $\Grass(k,n)$ as a subset of this projective space. Finally, to equip
$\Grass(k,n)$ with the structure of a projective variety, we need this fact: For non-zero
$w\in \bigwedge^kK^n$ the rank of the $K$-linear map $f:K^n \to \bigwedge^{k+1}K^n, v
\mapsto v \wedge w$ is at least $n-k$ and equality holds if, and only if, $w$ is a pure
tensor. Thus, using the above embedding, $\Grass(k,n)$ consists entirely of pure tensors
$w\in \Grass(k,n)$ which all define maps $v\mapsto v\wedge w$ of rank at most $n-k$. This
is equivalent to all $(n-k+1) \times (n-k+1)$-minors of these maps vanishing which induces
polynomial equations in the Plücker coordinates of $\setP^{N-1}$ describing $\Grass(k,n)$,
hence it is in fact a projective variety.

On an additional note one can cover $\Grass(k,n)$ with copies of $\setA^{k(n-k)}$ to show
that the Grassmannian is an irreducible projective variety of dimension $k(n-k)$. This
leads to the following definition:

\begin{definition}[Tropical Grassmannians]
  By the above a Grassmannian can be viewed as a projective variety given by the
  homogeneous prime ideal
  \[
    I(\Grass(k,n)) \idealof K[ p_{i_1, \dots, i_k} : 1\leq i_1 < \cdots < i_k \leq n ]
  \]
  with Plücker coordinates $p_{i_1,\dots,i_k}$ which defines a determinantal variety
  $\Grass(k, n)$. This, in turn, defines a tropical variety and we write $\mathcal G_{k,n}
  = \Trop(I(\Grass(k,n)))$ which is the support of a pure $k(n-k)+1$-dimensional fan (or
  polyhedral complex).
\end{definition}

\begin{figure}[tbhp]
  \centering
  \begin{tikzpicture}[thick]
    \foreach \x in {0, 1, ..., 4}
    {
      \fill ({\x*72+90}:1) circle (3pt);
      \fill ({\x*72+90}:2) circle (3pt);
      \draw ({\x*72+90}:1) -- ({\x*72+90}:2);
      \draw ({\x*72+90}:1) -- ({\x*72+234}:1);
      \draw ({\x*72+90}:2) -- ({\x*72+162}:2);
    }
  \end{tikzpicture}
  \caption{Petersen graph illustrating $\mathcal G_{2,5}$ reduced to a polyhedral complex}
  \label{fig:petersen}
\end{figure}

\begin{example} \label{ex:tropGrass}
  Suppose, for instance, $K = \setC$ as a subfield of $\CCt$, hence we our algorithms work
  with polyhedral fans as was remarked before.
  \begin{enumerate}
    \item As we clearly have $\Grass(0,n) \cong \Grass(n,n) \cong \{0\}$ and $\Grass(1,n)
      \cong \Grass(n-1, n) \cong \setP_K^{n-1}$, the first \enquote{non-trivial}
      Grassmannian is $\Grass(2,4)$. By the process described above one easily finds that
      $\Grass(2,4)$ is given by the ideal
      \[
        I_{2,4} = \ideal{ x_{i,j} \phi : 1 \leq i < j \leq 4 }
        \idealof K[x_{1,2}, \dots, x_{3,4}].
      \]
      for $\phi = x_{1,2}x_{3,4} - x_{1,3}x_{2,4} + x_{1,4}x_{2,3}$, but $\dim I_{2,4} =
      5$, so it defines a hypersurface in $\setP^5$. It can be shown that in fact
      $\sqrt{I_{2,4}} = \ideal \phi$, so $\Grass(2,4) = V(\phi)$ as one would expect.
      Hence the polyhedral fan corresponding to the tropical variety $\mathcal G_{2,4}$
      has maximal five-dimensional cones living in $\setR^6$.

      Computations show that $\mathcal G_{2,4}$ consists of three five-dimensional cones
      with four-dimensional homogeneity-space as their common facet. In particular,
      $\mathcal G_{2,4}$ is combinatorially a curve and $\mathcal G_{2,4}/C_0(\phi)$ is a
      tropical line consisting of three rays from the origin.
    \item The next non-trivial Grassmannian $\Grass(2,5)$ is given by an ideal $I_{2,5}$
      generated by five similar quadrics from the polynomial ring $K[x_{1,2}, \dots,
      x_{4,5}]$ in ten variables. In fact, we considered it already in
      Example~\ref{ex:pointG25}. Its tropical variety $\mathcal G_{2,5}$ is given by a
      seven-dimensional fan consisting of ten seven-dimensional cones and fifteen
      six-dimensional cones. Each maximal cone has three of the fifteen six-dimensional
      cones as facets. The homogeneity space $C_0(I_{2,5})$ is five-dimensional.
      Intersecting $\mathcal G_{2,5}/C_0(I_{2,5})$ with the unit sphere in $\setR^{10}$
      yields a polyhedral complex which can be interpreted as the \emph{Petersen graph} in
      ten nodes and fifteen vertices. It is illustrated in Figure~\ref{fig:petersen} --
      note that edges and vertices \emph{both} correspond to polyhedra of the complex. For
      details see for instance \cite[Example~9.10]{sturmSolve}.
  \end{enumerate}
\end{example}

\subsection{Runtime Measurements}

We come to timing our computations and comparing them to the pure implementation in
\textsc{Singular}. One additional notion we want to consider when studying tropical
varieties is the so-called \emph{$f$-vector} of the polyhedral fan it corresponds to. The
$f$-vector simply counts all polyhedra in the fan grouped by dimension: More precisely,
the $f$-vector of a $d$-dimensional polyhedral complex $\mathcal C$ is $(f_1, f_2, \dots,
f_d) \in \setN^d$ where $\mathcal C$ contains $f_i$ polyhedra of dimension $i$. In that
regard, it gives an intuition for the \enquote{size} of the computational problem.

\begin{example} \label{ex:fVec}
  Continuing Example~\ref{ex:tropGrass}, the $f$-vector of $\mathcal G_{2,4}$ is
  $(0,0,0,1,3)$ and that of $\mathcal G_{2,5}$ is $(0,0,0,0,1,15,10)$. Often, leading
  zeroes of the $f$-vector, which correspond to dimensions below the dimension of the
  lineality space resp.\ the homogeneity space of the fan are omitted.
\end{example}

First, we want to look at $\mathcal G_{3,7}$. Using the fan structure induced by the
Gröbner fan, \cite[Theorem~2.1]{tropPlane} stated that this tropical Grassmannian has
$f$-vector
\[
  (0,0,0,0,0,0,0,1,721,16800,124180,386155,522585,252000)
\]
including leading zeroes. Hence, if we wanted to compute $\mathcal G_{3,7}$ without
symmetry we would have to compute 252.000 Gröbner cones, which -- as it turns out -- is
quite time-consuming, even with the massively parallel approach we use here. Luckily, a
canonical symmetry group for any $\mathcal G_{k,n}$ is well known: The symmetry group
$S_7$ acts naturally on the indices of the Plücker coordinates of $\Grass(3,7)$, and we
may lift it to a subgroup of $S_{35}$ of size $7! = 5040$. Then, as stated after
\cite[Theorem~2.2]{tropPlane}, the tropical Grassmannian $\mathcal G_{3,7}$ modulo $S_7$
has $f$-vector
\[
  (0,0,0,0,0,0,0,1,6,37,140,296,300,125)
\]
which is much more manageable -- in fact, $\mathcal G_{3,7}$ can be computed on most
personal computers in a relatively small amount of time. On one of the compute nodes
described above the \enquote{pure} single-threaded \textsc{Singular}-version of the
traversal algorithm takes about {672.19} seconds averaged over 8 runs. Note that this
version of the algorithm has parts implemented in a dynamic \Cpp-module that were
translated into the slower \text{Singular} interpreter language in the GPI-Space
implementation.

\begin{table}[tbh]
  \centering
  \begin{tabular}{r||r|r||r}
                   & \multicolumn{2}{c||}{\textbf{time in seconds}} &\\
    \textbf{cores} & \textbf{one machine} & \textbf{two machines} &
    \textbf{efficiency} \\ \hline
    1   & 792.806 &      -- & 1 \\
    2   & 389.855 & 375.859 & 1.017--1.054 \\
    4   & 190.589 & 191.739 & 1.034--1.040 \\
    8   &  99.254 &  96.990 & 0.998--1.022 \\
    12  &  74.158 &      -- & 0.891 \\
    16  &  59.599 &  56.512 & 0.831--0.878 \\
    24  &      -- &  42.803 & 0.772 \\
    32  &      -- &  39.756 & 0.623
  \end{tabular}
  \caption{Timings of computing $\mathcal G_{3,7}$ in parallel.}
  \label{tab:g37}
\end{table}

In Table~\ref{tab:g37} we provide timings for running the computation of $\mathcal
G_{3,7}$ modulo $S_7$, using up to 32 processor cores on one and two machines
respectively. The timings are averages of eight runs each. These timings are plotted in
Figure~\ref{fig:g37sc} together with two extrapolated hyperbolas corresponding to the
minimal and maximal running times respectively, observed for two cores on one machine. The
parallelization \emph{efficiency} above is simply
\[
  \frac{ \text{running time on one core} }{ n \cdot (\text{running time on $n$ cores})}
\]
for each core count $n$ and describes the ratio between total processor time needed for
one core and $n$ cores respectively. If the number is greater than 1, computing on $n$
cores is not only faster but also more efficient. Similarly, if the number is less than 1
we lose efficiency for instance due to bottlenecks and scheduling overhead. We see that
computing times scale linearly with processor core count up to eight cores. However,
starting with 12 threads we observe a sudden drop in the speed-up which worsens for
increasing core counts. This can also be observed in the lower plot in
Figure~\ref{fig:g37sc}, where the curve through the mean running times flattens earlier
than the expected hyperbolas. In this case, the loss of parallelization efficiency is not
related to implementational problems or algorithmic overhead: Indeed, due to the structure
of the fan the set of unprocessed Gröbner cones, that is, the \emph{frontier nodes} of the
corresponding incidence graph, has a maximum size much smaller than 125. Using more
processor cores than this maximum size will leave some workers idle during execution,
and hence provides less or even no speed-up at all.

\begin{figure}[htbp]
  \begin{center}
    \input{fig/scaling37-1.tex}
  \end{center}
  \caption{Running times of computing $\mathcal{G}_{3,7}$ on one and two nodes}
  \label{fig:g37sc}
\end{figure}

This example is interesting to us since it has already been studied quite thoroughly but
does not parallelize well beyond two compute nodes. Hence in the next step we want to
consider the tropical Grassmannian $\mathcal G_{3,8}$ which turns out to be much larger.
Of course, we again want to consider this Grassmannian modulo symmetry: in the same way as
above the symmetry group $S_8$ acts on the Plücker coordinates and lifts to a subgroup
$S_8 \leq S_{56}$ of size $8!=40320$ -- recall that $\Grass(3,8)$ is given by an ideal
over the polynomial ring in 56 variables. Note that the size of the symmetry group also
plays into the running times since we usually iterate over all elements of $S_8$ to find
the minimal representative of a interior point.

\begin{table}[tbh]
  \centering
  \begin{tabular}{r|r||r|r}
    \textbf{nodes} & \textbf{cores} & \textbf{run time [s]} & \textbf{efficiency} \\
    \hline
     1 &  16 & 98926.120 & 0.586 \\
     2 &  32 & 37398.740 & 0.775 \\
     4 &  64 & 14486.337 & 1     \\
     8 & 128 &  6597.369 & 1.098 \\
    16 & 256 &  3297.911 & 1.098 \\
    24 & 384 &  2506.033 & 0.963 \\
    32 & 512 &  2001.769 & 0.904 \\
    40 & 640 &  1509.658 & 0.959 \\
    48 & 768 &  1267.394 & 0.952 \\
    56 & 896 &  1188.226 & 0.959
  \end{tabular}
  \caption{Timings of computing $\mathcal G_{3,8}$, using all 16 cores per node}
  \label{tab:g38}
\end{table}

As, at the time of our experiments, the number of Gröbner cones in $\mathcal G_{3,8}$
modulo $S_8$ was not known, we gradually computed larger and larger sets of
cones\footnote{While mainly a debug feature, Christian Reinbold included a setting to
terminate after computing a fixed amount of cones}, starting out with 1000 and ending up
with {20,000}, where we then saw that all cones had been computed: By our calculations
$\mathcal G_{3,8}$ modulo $S_8$ has $f$-vector
\[
  (0,0,0,0,0,0,0,0,1,95,1098,6671,24196,53648,70557,50125,14763),
\]
however the recombination into the full fan has proven to be too memory intensive even for
the high-memory compute servers in the mathematics department of TU
Kaiserslautern.\footnote{Computing the full $f$-vector from orbit representatives
\emph{efficiently} could be a research topic in and on itself.} Having obtained a full
solution, we started benchmarking this example. Timings of these runs are given in
\ref{tab:g38}. In contrast to $\mathcal G_{3,7}$, computations of $\mathcal G_{3,8}$ are
done in steps of whole compute nodes where all 16 processor cores are utilized. The
timings, taken as averages over at least 8 runs, are plotted in
Figure~\ref{fig:g38scaling}. Note that for 16 and 32 cores we only did five runs each due
to time constraints.

\begin{figure}[htb]
  \begin{center}
    \input{fig/efficiency38.tex}
  \end{center}
  \caption{Parallelization efficiency of computing $\mathcal{G}_{3,8}$}
  \label{fig:g38efficiency}
\end{figure}

We again want to consider the parallelization efficiency tested in these runs. A graph of
this is given in Figure~\ref{fig:g38efficiency} but note that in this case we normalize
the efficiency to 4 compute nodes, that is, 64 processor cores. Here we observer very
interesting behavior: Firstly, the algorithm shows super-linear speed-up when passing from
16 to 64 -- in particular running on 64 cores is 6.8 times faster than running on 16 cores
while only using four times as many processor cores. This is quite counterintuitive:
possible explanations include memory and storage latencies on fewer machines.\todo{clarify}{}
Secondly, while we observe the expected degradation of parallelization efficiency after
128 cores, we also see some erratic behavior of the resulting graph. In particular the
runs for 32 nodes, that is, 512 cores, show an increase in total computation time, that
is, the combined running time of all individual processes, and drop in efficiency. We can
imagine two reasons for this:
\begin{itemize}
  \item As the sample size of runs is rather small, disturbances in the computing cluster
    can have significant impact on the average timings.
  \item More importantly, the computation of a starting cone via
    Algorithm~\ref{alg:tropicalPoint} and execution orders of simultaneously enabled
    transitions in GPI-Space are randomized, leading to different program flows for each
    invocation. This is further amplified by computations modulo symmetry: For different
    starting cones we will come across different representatives for the cone orbits.
    Also, computations in \texttt{puiseux.lib} are more time-expensive compared to the
    Newton-method described in Section~\ref{sec:newtonMethod} and their occurrence
    frequency varies greatly depending on the starting cone.
\end{itemize}

\begin{figure}[htbp]
  \begin{center}
    \input{fig/scaling38.tex}
  \end{center}
  \caption{Running times of computing $\mathcal{G}_{3,8}$}
  \label{fig:g38scaling}
\end{figure}

Despite the uncharacteristic form of the graph we still see that this algorithm scales
quite favorably, even for up to 896 processor cores, far exceeding our initial
expectations. In particular, even when scaled to 64 cores our efficiency values all lie
above $0{.}9$ (on average). We can conclude that parallelizing algorithms for algebraic
geometry with the methods provided by GPI-Space is a worthwhile endeavor and offers
tremendous speed-up.

\clearpage
\printbibliography

\end{document}
% vim: spell spelllang=en
